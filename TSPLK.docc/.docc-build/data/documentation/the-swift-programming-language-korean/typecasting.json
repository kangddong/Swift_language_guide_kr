{"primaryContentSections":[{"kind":"content","content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"타입 캐스팅 (Type casting)"}]},{"type":"text","text":" 은 인스턴스의 타입을 확인하거나 해당 인스턴스를 자체 클래스 계층 구조의 다른 곳에서 다른 상위 클래스 또는 하위 클래스로 취급하는 방법입니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift에서 타입 캐스팅은 "},{"type":"codeVoice","code":"is"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"as"},{"type":"text","text":" 연산자로 구현됩니다. 이 두 연산자는 값의 타입을 확인하거나 값을 다른 타입으로 캐스트하는 간단하고 표현적인 방법을 제공합니다."}]},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Protocols#%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%A4%80%EC%88%98%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B2%80%EC%82%AC-Checking-for-Protocol-Conformance"},{"type":"text","text":" 에서 설명한대로 타입 캐스팅을 사용하여 타입이 프로토콜을 준수하는지 확인할 수도 있습니다."}]},{"anchor":"타입-캐스팅을-위한-클래스-계층-정의-Defining-a-Class-Hierarchy-for-Type-Casting","level":2,"type":"heading","text":"타입 캐스팅을 위한 클래스 계층 정의 (Defining a Class Hierarchy for Type Casting)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"클래스와 하위 클래스의 계층도와 함께 타입 캐스팅을 사용하여 특정 클래스 인스턴스의 타입을 확인하고 같은 계층도 내에서 다른 클래스로 인스턴스를 캐스트 할 수 있습니다. 아래의 세 코드는 타입 캐스팅의 예제에서 사용하기 위해 클래스의 계층도와 해당 클래스의 인스턴스를 포함하는 배열을 정의합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"첫번째 코드는 "},{"type":"codeVoice","code":"MediaItem"},{"type":"text","text":" 이라는 새로운 기본 클래스를 정의합니다. 이 클래스는 디지털 미디어 라이브러리에 나타나는 모든 종류의 항목에 대한 기본 기능을 제공합니다. 특히 "},{"type":"codeVoice","code":"String"},{"type":"text","text":" 타입의 "},{"type":"codeVoice","code":"name"},{"type":"text","text":" 프로퍼티와 "},{"type":"codeVoice","code":"init(name:)"},{"type":"text","text":" 초기화 구문을 선언합니다 (영화와 노래를 포함하여 모든 미디어 항목은 이름을 가지고 있다고 가정합니다)."}]},{"type":"codeListing","syntax":"swift","code":["class MediaItem {","    var name: String","    init(name: String) {","        self.name = name","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"다음 코드는 "},{"type":"codeVoice","code":"MediaItem"},{"type":"text","text":" 의 두 개의 하위 클래스를 정의합니다. 첫번째 하위 클래스 "},{"type":"codeVoice","code":"Movie"},{"type":"text","text":" 는 영화 또는 필름에 대한 추가 정보를 캡슐화 합니다. 기본 "},{"type":"codeVoice","code":"MediaItem"},{"type":"text","text":" 클래스의 상단에 "},{"type":"codeVoice","code":"director"},{"type":"text","text":" 프로퍼티와 해당 초기화 구문을 추가합니다. 두번째 하위 클래스 "},{"type":"codeVoice","code":"Song"},{"type":"text","text":" 은 기본 클래스의 상단에 "},{"type":"codeVoice","code":"artist"},{"type":"text","text":" 프로퍼티와 초기화 구문을 추가합니다:"}]},{"type":"codeListing","syntax":"swift","code":["class Movie: MediaItem {","    var director: String","    init(name: String, director: String) {","        self.director = director","        super.init(name: name)","    }","}","","class Song: MediaItem {","    var artist: String","    init(name: String, artist: String) {","        self.artist = artist","        super.init(name: name)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"마지막 코드는 두 개의 "},{"type":"codeVoice","code":"Movie"},{"type":"text","text":" 인스턴스와 세 개의 "},{"type":"codeVoice","code":"Song"},{"type":"text","text":" 인스턴스를 포함하는 "},{"type":"codeVoice","code":"library"},{"type":"text","text":" 라는 배열 상수를 생성합니다. "},{"type":"codeVoice","code":"library"},{"type":"text","text":" 배열의 타입은 배열 리터럴의 내용으로 초기화하여 추론됩니다. Swift의 타입 검사기는 "},{"type":"codeVoice","code":"Movie"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"Song"},{"type":"text","text":" 이 "},{"type":"codeVoice","code":"MediaItem"},{"type":"text","text":" 의 상위 클래스를 공통으로 가지고 있으므로 "},{"type":"codeVoice","code":"library"},{"type":"text","text":" 배열에 대해 "},{"type":"codeVoice","code":"[MediaItem]"},{"type":"text","text":" 에 타입으로 추론할 수 있습니다:"}]},{"type":"codeListing","syntax":"swift","code":["let library = [","    Movie(name: \"Casablanca\", director: \"Michael Curtiz\"),","    Song(name: \"Blue Suede Shoes\", artist: \"Elvis Presley\"),","    Movie(name: \"Citizen Kane\", director: \"Orson Welles\"),","    Song(name: \"The One And Only\", artist: \"Chesney Hawkes\"),","    Song(name: \"Never Gonna Give You Up\", artist: \"Rick Astley\")","]","\/\/ the type of \"library\" is inferred to be [MediaItem]"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"library"},{"type":"text","text":" 에 저장된 항목은 여전히 "},{"type":"codeVoice","code":"Movie"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"Song"},{"type":"text","text":" 인스턴스 입니다. 그러나 이 배열의 항목을 반복하면 항목은 "},{"type":"codeVoice","code":"Movie"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"Song"},{"type":"text","text":" 이 아닌 "},{"type":"codeVoice","code":"MediaItem"},{"type":"text","text":" 타입으로 받습니다. 기본 타입으로 작업을 하려면 아래에 설명된대로 타입을 확인하거나 다른 타입으로 다운캐스트 해야합니다."}]},{"anchor":"타입-검사-Checking-Type","level":2,"type":"heading","text":"타입 검사 (Checking Type)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"인스턴스가 특정 하위 클래스 타입인지 확인하기 위해 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"타입 검사 연산자 (type check operator)"}]},{"type":"text","text":" ("},{"type":"codeVoice","code":"is"},{"type":"text","text":")를 사용합니다. 이 타입 검사 연산자는 인스턴스가 하위 클래스 타입이면 "},{"type":"codeVoice","code":"true"},{"type":"text","text":" 아니면 "},{"type":"codeVoice","code":"false"},{"type":"text","text":" 를 반환합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"아래의 예제는 "},{"type":"codeVoice","code":"library"},{"type":"text","text":" 배열에 "},{"type":"codeVoice","code":"Movie"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"Song"},{"type":"text","text":" 인스턴스의 숫자를 나타내는 "},{"type":"codeVoice","code":"movieCount"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"songCount"},{"type":"text","text":" 인 두 개의 변수를 정의합니다:"}]},{"type":"codeListing","syntax":"swift","code":["var movieCount = 0","var songCount = 0","","for item in library {","    if item is Movie {","        movieCount += 1","    } else if item is Song {","        songCount += 1","    }","}","","print(\"Media library contains \\(movieCount) movies and \\(songCount) songs\")","\/\/ Prints \"Media library contains 2 movies and 3 songs\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 예제는 "},{"type":"codeVoice","code":"library"},{"type":"text","text":" 배열의 모든 항목을 통해 반복합니다. 각 패스에서 "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" 루프는 배열에서 다음 "},{"type":"codeVoice","code":"MediaItem"},{"type":"text","text":" 을 "},{"type":"codeVoice","code":"item"},{"type":"text","text":" 상수에 설정합니다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"item is Movie"},{"type":"text","text":" 는 현재 "},{"type":"codeVoice","code":"MediaItem"},{"type":"text","text":" 이 "},{"type":"codeVoice","code":"Movie"},{"type":"text","text":" 인스턴스이면 "},{"type":"codeVoice","code":"true"},{"type":"text","text":" 를 반환하고 아니면 "},{"type":"codeVoice","code":"false"},{"type":"text","text":" 를 반환합니다. 유사하게 "},{"type":"codeVoice","code":"item is Song"},{"type":"text","text":" 은 항목이 "},{"type":"codeVoice","code":"Song"},{"type":"text","text":" 인스턴스인지 확인합니다. "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" 루프의 마지막에 "},{"type":"codeVoice","code":"movieCount"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"songCount"},{"type":"text","text":" 의 값은 "},{"type":"codeVoice","code":"MediaItem"},{"type":"text","text":" 인스턴스에서 얼마나 많은 각 타입을 포함하는지 카운트를 나타냅니다."}]},{"anchor":"다운-캐스팅-Downcasting","level":2,"type":"heading","text":"다운 캐스팅 (Downcasting)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"특정 클래스 타입의 상수 또는 변수는 하위 클래스의 인스턴스를 참조할 수 있습니다. 이것이 사실이라고 생각하는 경우 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"타입 캐스트 연산자 (type cast operator)"}]},{"type":"text","text":" ("},{"type":"codeVoice","code":"as?"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"as!"},{"type":"text","text":")를 사용하여 하위 클래스 타입으로 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"다운 캐스트 (downcast)"}]},{"type":"text","text":" 할 수 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"다운 캐스팅은 실패할 수 있으므로 타입 캐스트 연산자는 2가지 다른 형태로 제공됩니다. 조건부 형식 "},{"type":"codeVoice","code":"as?"},{"type":"text","text":" 은 다운 캐스트를 하려고 할 때 타입의 옵셔널 값을 반환합니다. 강제 형식 "},{"type":"codeVoice","code":"as!"},{"type":"text","text":" 은 다운 캐스트를 시도하고 단일 복합 동작으로 강제 언래핑합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"다운 캐스트가 성공할지 확신이 없을 때 조건부 형식의 타입 캐스트 연산자 ("},{"type":"codeVoice","code":"as?"},{"type":"text","text":")를 사용합니다. 이 연산자의 형식은 항상 옵셔널 값을 반환하고 다운 캐스트가 불가능하면 "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" 을 반환합니다. 이것은 다운 캐스트가 성공여부를 확인하는 용도로도 사용 가능합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"다운 캐스트가 항상 성공할 것이라는 확신이 있을 때만 강제 형식의 타입 캐스트 연산자 ("},{"type":"codeVoice","code":"as!"},{"type":"text","text":")를 사용합니다. 이 연산자의 형식은 유효하지 않은 클래스 타입으로 다운 캐스트를 시도하면 런타임 에러가 발생합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"아래의 예제는 "},{"type":"codeVoice","code":"library"},{"type":"text","text":" 에 각 "},{"type":"codeVoice","code":"MediaItem"},{"type":"text","text":" 을 반복하고 각 항목에 대한 적절한 설명을 출력합니다. 이렇게 하려면 "},{"type":"codeVoice","code":"MediaItem"},{"type":"text","text":" 이 아닌 "},{"type":"codeVoice","code":"Movie"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"Song"},{"type":"text","text":" 으로 각 항목에 접근해야 합니다. 이것은 설명을 사용하기 위해 "},{"type":"codeVoice","code":"Movie"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"Song"},{"type":"text","text":" 의 "},{"type":"codeVoice","code":"director"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"artist"},{"type":"text","text":" 프로퍼티에 접근할 수 있도록 하기위해 필요합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 예제는 배열의 각 항목은 "},{"type":"codeVoice","code":"Movie"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"Song"},{"type":"text","text":" 일 수 있습니다. 각 항목에 사용할 실제 클래스를 미리 알지 못하므로 루프를 통해 매번 다운 캐스트를 확인하기 위해 타입 캐스트 연산자 ("},{"type":"codeVoice","code":"as?"},{"type":"text","text":")의 조건부 형식을 사용하는 것이 적절합니다:"}]},{"type":"codeListing","syntax":"swift","code":["for item in library {","    if let movie = item as? Movie {","        print(\"Movie: \\(movie.name), dir. \\(movie.director)\")","    } else if let song = item as? Song {","        print(\"Song: \\(song.name), by \\(song.artist)\")","    }","}","","\/\/ Movie: Casablanca, dir. Michael Curtiz","\/\/ Song: Blue Suede Shoes, by Elvis Presley","\/\/ Movie: Citizen Kane, dir. Orson Welles","\/\/ Song: The One And Only, by Chesney Hawkes","\/\/ Song: Never Gonna Give You Up, by Rick Astley"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 예제는 "},{"type":"codeVoice","code":"Movie"},{"type":"text","text":" 로 현재 "},{"type":"codeVoice","code":"item"},{"type":"text","text":" 을 다운 캐스트 하는 것으로 시작합니다. "},{"type":"codeVoice","code":"item"},{"type":"text","text":" 은 "},{"type":"codeVoice","code":"MediaItem"},{"type":"text","text":" 인스턴스 이므로 "},{"type":"codeVoice","code":"Movie"},{"type":"text","text":" 일 수도 있고 마찬가지로 "},{"type":"codeVoice","code":"Song"},{"type":"text","text":" 일 수 있습니다. 또는 기본 "},{"type":"codeVoice","code":"MediaItem"},{"type":"text","text":" 일 수도 있습니다. 이 불확실성 때문에 타입 캐스트 연산자의 "},{"type":"codeVoice","code":"as?"},{"type":"text","text":" 형식은 하위 클래스 타입으로 다운 캐스트를 시도할 때 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"옵셔널"}]},{"type":"text","text":" 값으로 반환합니다. "},{"type":"codeVoice","code":"item as? Movie"},{"type":"text","text":" 의 결과는 "},{"type":"codeVoice","code":"Movie?"},{"type":"text","text":" 타입 또는 “옵셔널 "},{"type":"codeVoice","code":"Movie"},{"type":"text","text":"” 입니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"라이브러리 배열에 "},{"type":"codeVoice","code":"Song"},{"type":"text","text":" 인스턴스로 적용할 때 "},{"type":"codeVoice","code":"Movie"},{"type":"text","text":" 로 다운 캐스팅은 실패합니다. 이것을 대응하기 위해 위의 예제는 옵셔널 "},{"type":"codeVoice","code":"Movie"},{"type":"text","text":" 가 실제 값에 포함되어 있는지 확인하기 위해 (다운 캐스트가 성공 되었는지 확인하기 위해) 옵셔널 바인딩을 사용합니다. 이 옵셔널 바인딩은 “"},{"type":"codeVoice","code":"if let movie = item as? Movie"},{"type":"text","text":"” 로 작성되고 아래와 같이 읽을 수 있습니다:"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"“"},{"type":"codeVoice","code":"Movie"},{"type":"text","text":" 로 "},{"type":"codeVoice","code":"item"},{"type":"text","text":" 은 접근하려고 합니다. 성공하면 반환된 옵셔널 "},{"type":"codeVoice","code":"Movie"},{"type":"text","text":" 를 "},{"type":"codeVoice","code":"movie"},{"type":"text","text":" 라는 새로운 임시 상수로 설정합니다.”"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"다운 캐스팅이 성공하면 "},{"type":"codeVoice","code":"movie"},{"type":"text","text":" 의 프로퍼티는 "},{"type":"codeVoice","code":"director"},{"type":"text","text":" 의 이름을 포함하여 "},{"type":"codeVoice","code":"Movie"},{"type":"text","text":" 인스턴스에 대해 설명을 출력하는데 사용합니다. 유사한 원칙을 사용하여 "},{"type":"codeVoice","code":"Song"},{"type":"text","text":" 인스턴스를 확인하고 라이브러리에서 "},{"type":"codeVoice","code":"Song"},{"type":"text","text":" 을 찾을 때마다 "},{"type":"codeVoice","code":"artist"},{"type":"text","text":" 이름을 포함하여 적절한 설명을 출력하는데 사용합니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Note"},{"type":"text","text":" "},{"type":"text","text":"캐스팅은 실제로 인스턴스를 수정하거나 값을 변경하지 않습니다. 기본 인스턴스는 동일하게 유지됩니다. 캐스트된 타입의 인스턴스로 처리하고 접근 합니다."}]}],"type":"aside","name":"Note"},{"anchor":"Any-와-AnyObject-에-대한-타입-캐스팅-Type-Casting-for-Any-and-AnyObject","level":2,"type":"heading","text":"Any 와 AnyObject 에 대한 타입 캐스팅 (Type Casting for Any and AnyObject)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift는 비특정 타입 작업을 위해 2개의 특별한 타입을 제공합니다:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Any"},{"type":"text","text":" 는 함수 타입을 포함하여 모든 타입의 인스턴스를 나타낼 수 있습니다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"AnyObject"},{"type":"text","text":" 는 모든 클래스 타입의 인스턴스를 나타낼 수 있습니다."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"제공하는 동작과 기능이 명시적으로 필요한 경우에만 "},{"type":"codeVoice","code":"Any"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"AnyObject"},{"type":"text","text":" 를 사용합니다. 코드에서 작업할 것으로 예상되는 타입에 대해 구체적으로 지정하는 것이 항상 좋습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"다음은 함수 타입과 비 클래스 타입을 포함하여 다른 타입에 혼합으로 작업하기 위해 "},{"type":"codeVoice","code":"Any"},{"type":"text","text":" 를 사용하는 예제입니다. 이 예제는 "},{"type":"codeVoice","code":"Any"},{"type":"text","text":" 타입에 값을 저장할 수 있는 "},{"type":"codeVoice","code":"things"},{"type":"text","text":" 라는 배열을 생성합니다:"}]},{"type":"codeListing","syntax":"swift","code":["var things: [Any] = []","","things.append(0)","things.append(0.0)","things.append(42)","things.append(3.14159)","things.append(\"hello\")","things.append((3.0, 5.0))","things.append(Movie(name: \"Ghostbusters\", director: \"Ivan Reitman\"))","things.append({ (name: String) -> String in \"Hello, \\(name)\" })"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"things"},{"type":"text","text":" 배열은 2개의 "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 값, 2개의 "},{"type":"codeVoice","code":"Double"},{"type":"text","text":" 값, 하나의 "},{"type":"codeVoice","code":"String"},{"type":"text","text":" 값, 하나의 "},{"type":"codeVoice","code":"(Double, Double)"},{"type":"text","text":" 타입의 튜플, “Ghostbusters” 영화, 그리고 "},{"type":"codeVoice","code":"String"},{"type":"text","text":" 값과 다른 "},{"type":"codeVoice","code":"String"},{"type":"text","text":" 값을 반환하는 클로저 표현식을 포함합니다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Any"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"AnyObject"},{"type":"text","text":" 타입으로만 알려진 상수 또는 변수의 특정 타입을 알아보려면 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문의 케이스로 "},{"type":"codeVoice","code":"is"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"as"},{"type":"text","text":" 패턴을 사용할 수 있습니다. 아래의 예제는 "},{"type":"codeVoice","code":"things"},{"type":"text","text":" 배열에 항목을 반복하고 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문으로 각 항목의 타입을 조회합니다. 몇몇의 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문의 케이스는 일치된 값을 지정된 타입의 상수에 바인딩하여 해당 값을 출력할 수 있도록 합니다:"}]},{"type":"codeListing","syntax":"swift","code":["for thing in things {","    switch thing {","    case 0 as Int:","        print(\"zero as an Int\")","    case 0 as Double:","        print(\"zero as a Double\")","    case let someInt as Int:","        print(\"an integer value of \\(someInt)\")","    case let someDouble as Double where someDouble > 0:","        print(\"a positive double value of \\(someDouble)\")","    case is Double:","        print(\"some other double value that I don't want to print\")","    case let someString as String:","        print(\"a string value of \\\"\\(someString)\\\"\")","    case let (x, y) as (Double, Double):","        print(\"an (x, y) point at \\(x), \\(y)\")","    case let movie as Movie:","        print(\"a movie called \\(movie.name), dir. \\(movie.director)\")","    case let stringConverter as (String) -> String:","        print(stringConverter(\"Michael\"))","    default:","        print(\"something else\")","    }","}","","\/\/ zero as an Int","\/\/ zero as a Double","\/\/ an integer value of 42","\/\/ a positive double value of 3.14159","\/\/ a string value of \"hello\"","\/\/ an (x, y) point at 3.0, 5.0","\/\/ a movie called Ghostbusters, dir. Ivan Reitman","\/\/ Hello, Michael"]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Note"},{"type":"text","text":" "},{"type":"codeVoice","code":"Any"},{"type":"text","text":" 타입은 옵셔널 타입을 포함하여 모든 타입의 값을 나타냅니다. Swift는 "},{"type":"codeVoice","code":"Any"},{"type":"text","text":" 타입의 값이 기대되는 곳에 옵셔널 값을 사용하면 경고를 줍니다. "},{"type":"codeVoice","code":"Any"},{"type":"text","text":" 값으로 옵셔널 값을 사용하는 것이 필요하다면 아래와 같이 "},{"type":"codeVoice","code":"as"},{"type":"text","text":" 연산자를 사용하여 명시적으로 옵셔널을 "},{"type":"codeVoice","code":"Any"},{"type":"text","text":" 로 캐스트 할 수 있습니다."}]},{"type":"codeListing","syntax":"swift","code":["let optionalNumber: Int? = 3","things.append(optionalNumber)        \/\/ Warning","things.append(optionalNumber as Any) \/\/ No warning"]}],"type":"aside","name":"Note"}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"identifier":{"url":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TypeCasting","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"값의 런타임 타입을 정하고 타입의 정보를 제공합니다."}],"kind":"article","metadata":{"title":"타입 캐스팅 (Type Casting)"},"hierarchy":{"paths":[["doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean"]]},"references":{"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Protocols#%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%A4%80%EC%88%98%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B2%80%EC%82%AC-Checking-for-Protocol-Conformance":{"abstract":[],"title":"프로토콜 준수에 대한 검사 (Checking for Protocol Conformance)","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Protocols#%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%A4%80%EC%88%98%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B2%80%EC%82%AC-Checking-for-Protocol-Conformance","url":"\/documentation\/the-swift-programming-language-korean\/protocols#%25ED%2594%2584%25EB%25A1%259C%25ED%2586%25A0%25EC%25BD%259C-%25EC%25A4%2580%25EC%2588%2598%25EC%2597%2590-%25EB%258C%2580%25ED%2595%259C-%25EA%25B2%2580%25EC%2582%25AC-Checking-for-Protocol-Conformance"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean":{"role":"collection","title":"The Swift Programming Language (한국어)","abstract":[],"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language-korean"}}}