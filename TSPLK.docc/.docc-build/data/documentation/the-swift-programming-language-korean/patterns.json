{"primaryContentSections":[{"kind":"content","content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"패턴 (pattern)"}]},{"type":"text","text":" 은 단일 값 또는 복합 값의 구조를 나타냅니다. 예를 들어 튜플 "},{"type":"codeVoice","code":"(1, 2)"},{"type":"text","text":" 의 구조는 콤마로 구분된 두 요소의 리스트입니다. 패턴은 특정값이 아닌 값의 구조를 나타내기 때문에 다양한 값과 일치 시킬 수 있습니다. 예를 들어 패턴 "},{"type":"codeVoice","code":"(x, y)"},{"type":"text","text":" 은 튜플 "},{"type":"codeVoice","code":"(1, 2)"},{"type":"text","text":" 와 다른 두 요소 튜플과 일치합니다. 패턴을 값과 일치시키는 것 외에도 복합 값의 일부 또는 전체를 추출하고 각 부분을 상수 또는 변수 이름으로 바인드 할 수 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift 에는 두가지의 기본 패턴이 있습니다: 모든 종류의 값과 일치하는 패턴과 런타임에 지정된 값과 일치하지 않을 수 있는 패턴이 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"패턴의 첫번째 종류는 단순 변수, 상수, 그리고 옵셔널 바인딩에서 값을 구조화 하는데 사용됩니다. 와일드 카드 패턴, 식별자 패턴, 그리고 이를 포함하는 모든 값 바인딩 또는 튜플 패턴이 포함됩니다. 이러한 패턴에 타입 주석을 지정하여 특정 타입의 값만 일치되도록 제한할 수 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"패턴의 두번째 종류는 전체 패턴 일치에 사용되며 일치하려는 값이 런타임 때 없을 수 있습니다. 열거형 케이스 패턴, 옵셔널 패턴, 표현식 패턴, 그리고 타입-캐스팅 패턴을 포함합니다. "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문의 케이스 라벨, "},{"type":"codeVoice","code":"do"},{"type":"text","text":" 구문의 "},{"type":"codeVoice","code":"catch"},{"type":"text","text":" 절, 또는 "},{"type":"codeVoice","code":"if"},{"type":"text","text":", "},{"type":"codeVoice","code":"while"},{"type":"text","text":", "},{"type":"codeVoice","code":"guard"},{"type":"text","text":", 또는 "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" 구문의 케이스 조건에서 이 패턴을 사용합니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"wildcard-pattern"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-annotation"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier-pattern"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-annotation"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"value-binding-pattern"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-annotation"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"enum-case-pattern"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"optional-pattern"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-casting-pattern"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression-pattern"}]}]}],"type":"aside","name":"Grammar of a pattern"},{"anchor":"와일드-카드-패턴-Wildcard-Pattern","level":2,"type":"heading","text":"와일드 카드 패턴 (Wildcard Pattern)"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"와일드 카드 패턴 (wildcard pattern)"}]},{"type":"text","text":" 은 모든 값과 일치하고 무시되며 언더바 ("},{"type":"codeVoice","code":"_"},{"type":"text","text":") 로 구성됩니다. 일치하는 값에 대해 신경쓰지 않을 경우에 와일드 카드 패턴을 사용합니다. 예를 들어 다음의 코드는 닫긴 범위 "},{"type":"codeVoice","code":"1...3"},{"type":"text","text":" 을 반복하고 루프의 각 반복의 범위의 현재값을 무시합니다:"}]},{"type":"codeListing","syntax":"swift","code":["for _ in 1...3 {","    \/\/ Do something three times.","}"]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"wildcard-pattern"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"_"}]}]}],"type":"aside","name":"Grammar of a wildcard pattern"},{"anchor":"식별자-패턴-Identifier-Pattern","level":2,"type":"heading","text":"식별자 패턴 (Identifier Pattern)"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"식별자 패턴 (identifier pattern)"}]},{"type":"text","text":" 은 모든 값과 일치하고 일치하는 값을 변수 또는 상수 이름으로 바인드 합니다. 예를 들어 다음의 상수 선언에서 "},{"type":"codeVoice","code":"someValue"},{"type":"text","text":" 는 타입 "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 의 "},{"type":"codeVoice","code":"42"},{"type":"text","text":" 값이 일치하는 식별자 패턴입니다:"}]},{"type":"codeListing","syntax":"swift","code":["let someValue = 42"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"일치가 성공하면 값 "},{"type":"codeVoice","code":"42"},{"type":"text","text":" 는 상수 이름 "},{"type":"codeVoice","code":"someValue"},{"type":"text","text":" 에 바인드 (할당) 됩니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"변수 또는 상수 선언의 왼쪽의 패턴이 식별자 패턴일 때 식별자 패턴은 암시적으로 값-바인딩 패턴 (value-binding pattern) 의 하위 패턴입니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier-pattern"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier"}]}]}],"type":"aside","name":"Grammar of an identifier pattern"},{"anchor":"값-바인딩-패턴-Value-Binding-Pattern","level":2,"type":"heading","text":"값-바인딩 패턴 (Value-Binding Pattern)"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"값-바인딩 패턴 (value-binding pattern)"}]},{"type":"text","text":" 은 변수 또는 상수 이름에 일치되는 값으로 바인드 합니다. 상수의 이름에 일치되는 값을 바인드 하는 값-바인딩 패턴은 "},{"type":"codeVoice","code":"let"},{"type":"text","text":" 키워드로 시작합니다; 변수의 이름에 바인드 하면 "},{"type":"codeVoice","code":"var"},{"type":"text","text":" 키워드로 시작합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"값-바인딩 패턴 내에서 식별자 패턴은 일치하는 값으로 새로운 명명된 변수 또는 상수로 바인드 됩니다. 예를 들어 튜플의 요소를 분해하고 각 요소의 값을 해당 식별자 패턴에 바인드 할 수 있습니다."}]},{"type":"codeListing","syntax":"swift","code":["let point = (3, 2)","switch point {","    \/\/ Bind x and y to the elements of point.","case let (x, y):","    print(\"The point is at (\\(x), \\(y)).\")","}","\/\/ Prints \"The point is at (3, 2).\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"위의 예제에서 "},{"type":"codeVoice","code":"let"},{"type":"text","text":" 은 튜플 패턴 "},{"type":"codeVoice","code":"(x, y)"},{"type":"text","text":" 에서 각 식별자 패턴에 배포합니다. 이 동작으로 인해 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 케이스 "},{"type":"codeVoice","code":"case let (x, y):"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"case (let x, let y):"},{"type":"text","text":" 은 동일합니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"value-binding-pattern"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"var"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"type":"text","text":" | "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"let"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]}]}],"type":"aside","name":"Grammar of a value-binding pattern"},{"anchor":"튜플-패턴-Tuple-Pattern","level":2,"type":"heading","text":"튜플 패턴 (Tuple Pattern)"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"튜플 패턴 (tuple pattern)"}]},{"type":"text","text":" 은 소괄호로 묶인 콤마로 구분된 0개 이상의 패턴의 리스트입니다. 튜플 패턴은 해당 튜플 타입의 값과 일치합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"타입 주석을 사용하여 튜플 타입의 특정 종류와 일치하도록 하기 위해 튜플 패턴을 제한할 수 있습니다. 예를 들어 상수 선언 "},{"type":"codeVoice","code":"let (x, y): (Int, Int) = (1, 2)"},{"type":"text","text":" 에서 튜플 패턴 "},{"type":"codeVoice","code":"(x, y): (Int, Int)"},{"type":"text","text":" 은 두 요소 모두 타입 "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 의 튜플 타입만 일치합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"튜플 패턴이 "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" 구문 또는 변수 또는 상수 선언에서 패턴으로 사용되면 와일드 카드 패턴, 식별자 패턴, 옵셔널 패턴, 또는 이를 포함하는 다른 튜플 패턴만 포함할 수 있습니다. 예를 들어 튜플 패턴 "},{"type":"codeVoice","code":"(x, 0)"},{"type":"text","text":" 에서 요소 "},{"type":"codeVoice","code":"0"},{"type":"text","text":" 은 표현식 패턴이므로 다음의 코드는 유효하지 않습니다:"}]},{"type":"codeListing","syntax":"swift","code":["let points = [(0, 0), (1, 0), (1, 1), (2, 0), (2, 1)]","\/\/ This code isn't valid.","for (x, 0) in points {","    \/* ... *\/","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"단일 요소를 포함하는 튜플 패턴 주변의 소괄호는 아무런 효과가 없습니다. 패턴은 단일 요소의 타입의 값과 일치합니다. 예를 들어 다음은 동일합니다:"}]},{"type":"codeListing","syntax":"swift","code":["let a = 2        \/\/ a: Int = 2","let (a) = 2      \/\/ a: Int = 2","let (a): Int = 2 \/\/ a: Int = 2"]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"("}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern-element-list"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":")"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern-element-list"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern-element"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern-element"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":","}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern-element-list"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern-element"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":":"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]}]}],"type":"aside","name":"Grammar of a tuple pattern"},{"anchor":"열거형-케이스-패턴-Enumeration-Case-Pattern","level":2,"type":"heading","text":"열거형 케이스 패턴 (Enumeration Case Pattern)"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"열거형 케이스 패턴 (enumeration case pattern)"}]},{"type":"text","text":" 은 존재하는 열거형 타입의 케이스와 일치합니다. 열거형 케이스 패턴은 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문 케이스 라벨과 "},{"type":"codeVoice","code":"if"},{"type":"text","text":", "},{"type":"codeVoice","code":"while"},{"type":"text","text":", "},{"type":"codeVoice","code":"guard"},{"type":"text","text":", 그리고 "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" 구문의 케이스 조건에서 나타납니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"일치 시키려는 열거형 케이스에 연관된 값이 있는 경우 해당 열거형 케이스 패턴은 각 연관된 값에 대한 하나의 요소를 포함하는 튜플 패턴을 지정해야 합니다. 연관된 값을 포함하는 열거형 케이스를 일치 시키기 위해 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문을 사용하는 예제는 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Enumerations#%EC%97%B0%EA%B4%80%EB%90%9C-%EA%B0%92-Associated-Values"},{"type":"text","text":" 을 참고 바랍니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"열거형 케이스 패턴은 옵셔널로 래핑된 케이스의 값과도 일치합니다. 이 간략한 구문으로 옵셔널 패턴을 생략할 수 있습니다. "},{"type":"codeVoice","code":"Optional"},{"type":"text","text":" 은 열거형으로 구현되므로 "},{"type":"codeVoice","code":".none"},{"type":"text","text":" 과 "},{"type":"codeVoice","code":".some"},{"type":"text","text":" 은 열거형 타입의 케이스로 동일한 switch 에 나타날 수 있습니다."}]},{"type":"codeListing","syntax":"swift","code":["enum SomeEnum { case left, right }","let x: SomeEnum? = .left","switch x {","case .left:","    print(\"Turn left\")","case .right:","    print(\"Turn right\")","case nil:","    print(\"Keep going straight\")","}","\/\/ Prints \"Turn left\""]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"enum-case-pattern"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-identifier"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"."}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"enum-case-name"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]}]}],"type":"aside","name":"Grammar of an enumeration case pattern"},{"anchor":"옵셔널-패턴-Optional-Pattern","level":2,"type":"heading","text":"옵셔널 패턴 (Optional Pattern)"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"옵셔널 패턴 (optional pattern)"}]},{"type":"text","text":" 은 "},{"type":"codeVoice","code":"Optional<Wrapped>"},{"type":"text","text":" 열거형의 "},{"type":"codeVoice","code":"some(Wrapped)"},{"type":"text","text":" 케이스에 래핑된 값과 일치합니다. 옵셔널 패턴은 식별자 패턴과 물음표 바로 뒤에 오는 것으로 구성되며 열거형 케이스 패턴과 동일한 위치에 나타납니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"옵셔널 패턴은 "},{"type":"codeVoice","code":"Optional"},{"type":"text","text":" 열거형 케이스 패턴에 대한 구문 설탕 이므로 다음은 동일합니다:"}]},{"type":"codeListing","syntax":"swift","code":["let someOptional: Int? = 42","\/\/ Match using an enumeration case pattern.","if case .some(let x) = someOptional {","    print(x)","}","","\/\/ Match using an optional pattern.","if case let x? = someOptional {","    print(x)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"옵셔널 패턴은 "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" 구문에서 옵셔널 값의 배열을 반복하는 편리한 방법을 제공하여 "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" 이 아닌 요소에 대해서만 루프의 본문을 실행합니다."}]},{"type":"codeListing","syntax":"swift","code":["let arrayOfOptionalInts: [Int?] = [nil, 2, 3, nil, 5]","\/\/ Match only non-nil values.","for case let number? in arrayOfOptionalInts {","    print(\"Found a \\(number)\")","}","\/\/ Found a 2","\/\/ Found a 3","\/\/ Found a 5"]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"optional-pattern"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier-pattern"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"?"}]}]}],"type":"aside","name":"Grammar of an optional pattern"},{"anchor":"타입-캐스팅-패턴-Type-Casting-Patterns","level":2,"type":"heading","text":"타입-캐스팅 패턴 (Type-Casting Patterns)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"타입-캐스팅 패턴 (type-casting pattern) 은 "},{"type":"codeVoice","code":"is"},{"type":"text","text":" 패턴과 "},{"type":"codeVoice","code":"as"},{"type":"text","text":" 패턴 두가지가 있습니다. "},{"type":"codeVoice","code":"is"},{"type":"text","text":" 패턴은 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문 케이스 라벨에서만 나타납니다. "},{"type":"codeVoice","code":"is"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"as"},{"type":"text","text":" 패턴은 다음의 형식을 가집니다:"}]},{"type":"codeListing","syntax":"swift","code":["is <#type#>","<#pattern#> as <#type#>"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"is"},{"type":"text","text":" 패턴은 런타임 시 해당 값의 타입이 "},{"type":"codeVoice","code":"is"},{"type":"text","text":" 패턴의 오른편에 지정한 타입과 일치하거나 해당 타입의 하위 클래스가 일치하면 값으로 일치됩니다. "},{"type":"codeVoice","code":"is"},{"type":"text","text":" 패턴은 타입 캐스트를 동작하지만 반환된 타입을 버린다는 것에서 "},{"type":"codeVoice","code":"is"},{"type":"text","text":" 연산자와 유사하게 동작합니다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"as"},{"type":"text","text":" 패턴은 런타임 시 해당 값의 타입이 "},{"type":"codeVoice","code":"as"},{"type":"text","text":" 패턴의 오른편에 지정한 타입과 일치하거나 해당 타입의 하위 클래스가 일치하면 값으로 일치합니다. 일치가 성공하면 일치된 값의 타입은 "},{"type":"codeVoice","code":"as"},{"type":"text","text":" 패턴의 오른편에 지정한 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"패턴 (pattern)"}]},{"type":"text","text":" 으로 캐스팅 됩니다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"is"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"as"},{"type":"text","text":" 패턴으로 값을 일치 시키기 위해 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문을 사용하는 예제는 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TypeCasting#Any-%EC%99%80-AnyObject-%EC%97%90-%EB%8C%80%ED%95%9C-%ED%83%80%EC%9E%85-%EC%BA%90%EC%8A%A4%ED%8C%85-Type-Casting-for-Any-and-AnyObject"},{"type":"text","text":" 을 참고 바랍니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type-casting-pattern"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"is-pattern"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"as-pattern"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"is-pattern"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"is"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"as-pattern"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"as"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]}]}],"type":"aside","name":"Grammar of a type casting pattern"},{"anchor":"표현식-패턴-Expression-Pattern","level":2,"type":"heading","text":"표현식 패턴 (Expression Pattern)"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"표현식 패턴 (expression pattern)"}]},{"type":"text","text":" 은 표현식의 값을 표현합니다. 표현식 패턴은 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문 케이스 라벨에서만 나타납니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"표현식 패턴에 의해 표현된 표현식은 Swift 표준 라이브러리 "},{"type":"codeVoice","code":"~="},{"type":"text","text":" 연산자를 사용하여 입력 표현식의 값과 비교합니다. "},{"type":"codeVoice","code":"~="},{"type":"text","text":" 연산자가 "},{"type":"codeVoice","code":"true"},{"type":"text","text":" 를 반환하면 일치는 성공합니다. 기본적으로 "},{"type":"codeVoice","code":"~="},{"type":"text","text":" 연산자는 "},{"type":"codeVoice","code":"=="},{"type":"text","text":" 연산자를 사용하여 동일한 타입의 두 값을 비교합니다. 다음 예제에서 보듯이 범위내에 값이 포함되는지 검사하기 위해 값의 범위로 값을 일치시킬 수도 있습니다."}]},{"type":"codeListing","syntax":"swift","code":["let point = (1, 2)","switch point {","case (0, 0):","    print(\"(0, 0) is at the origin.\")","case (-2...2, -2...2):","    print(\"(\\(point.0), \\(point.1)) is near the origin.\")","default:","    print(\"The point is at (\\(point.0), \\(point.1)).\")","}","\/\/ Prints \"(1, 2) is near the origin.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"사용자 정의 표현식 일치 동작을 제공하기 위해 "},{"type":"codeVoice","code":"~="},{"type":"text","text":" 연산자를 오버로드 할 수 있습니다. 예를 들어 포인트의 문자열 표현으로 "},{"type":"codeVoice","code":"point"},{"type":"text","text":" 표현식을 비교하기 위해 위의 예제를 다시 작성할 수 있습니다."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Overload the ~= operator to match a string with an integer.","func ~= (pattern: String, value: Int) -> Bool {","    return pattern == \"\\(value)\"","}","switch point {","case (\"0\", \"0\"):","    print(\"(0, 0) is at the origin.\")","default:","    print(\"The point is at (\\(point.0), \\(point.1)).\")","}","\/\/ Prints \"The point is at (1, 2).\""]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"expression-pattern"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression"}]}]}],"type":"aside","name":"Grammar of an expression pattern"}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"identifier":{"url":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Patterns","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"값을 일치시키고 분리합니다."}],"kind":"article","metadata":{"title":"패턴 (Patterns)"},"hierarchy":{"paths":[["doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean"]]},"references":{"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean":{"role":"collection","title":"The Swift Programming Language (한국어)","abstract":[],"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language-korean"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/TypeCasting#Any-%EC%99%80-AnyObject-%EC%97%90-%EB%8C%80%ED%95%9C-%ED%83%80%EC%9E%85-%EC%BA%90%EC%8A%A4%ED%8C%85-Type-Casting-for-Any-and-AnyObject":{"abstract":[],"title":"Any 와 AnyObject 에 대한 타입 캐스팅 (Type Casting for Any and AnyObject)","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TypeCasting#Any-%EC%99%80-AnyObject-%EC%97%90-%EB%8C%80%ED%95%9C-%ED%83%80%EC%9E%85-%EC%BA%90%EC%8A%A4%ED%8C%85-Type-Casting-for-Any-and-AnyObject","url":"\/documentation\/the-swift-programming-language-korean\/typecasting#Any-%25EC%2599%2580-AnyObject-%25EC%2597%2590-%25EB%258C%2580%25ED%2595%259C-%25ED%2583%2580%25EC%259E%2585-%25EC%25BA%2590%25EC%258A%25A4%25ED%258C%2585-Type-Casting-for-Any-and-AnyObject"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Enumerations#%EC%97%B0%EA%B4%80%EB%90%9C-%EA%B0%92-Associated-Values":{"abstract":[],"title":"연관된 값 (Associated Values)","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Enumerations#%EC%97%B0%EA%B4%80%EB%90%9C-%EA%B0%92-Associated-Values","url":"\/documentation\/the-swift-programming-language-korean\/enumerations#%25EC%2597%25B0%25EA%25B4%2580%25EB%2590%259C-%25EA%25B0%2592-Associated-Values"}}}