{"primaryContentSections":[{"kind":"content","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"열거형은 특정 클래스 또는 구조체의 기능을 지원하기 위해 생성됩니다. 유사하게 더 복잡한 타입의 컨텍스트 내에서 사용하기 위해 순수하게 유틸리티 클래스와 구조체를 정의하는 것이 편리할 수 있습니다. 이를 위해 Swift는 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"중첩된 타입 (nested types)"}]},{"type":"text","text":" 을 정의할 수 있으며 지원하는 타입의 정의 내에서 열거형, 클래스, 그리고 구조체를 중첩할 수 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"다른 타입 내에서 타입을 중첩하려면 지원하는 타입의 외부 중괄호 내에 정의를 작성해야 합니다. 타입은 필요한만큼의 수준으로 중첩될 수 있습니다."}]},{"anchor":"중첩된-타입의-동작-Nested-Types-in-Action","level":2,"type":"heading","text":"중첩된 타입의 동작 (Nested Types in Action)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"아래의 예제는 블랙잭 게임에서 사용되는 게임 카드를 모델링하는 "},{"type":"codeVoice","code":"BlackjackCard"},{"type":"text","text":" 라는 구조체를 정의합니다. "},{"type":"codeVoice","code":"BlackjackCard"},{"type":"text","text":" 구조체는 "},{"type":"codeVoice","code":"Suit"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"Rank"},{"type":"text","text":" 라는 2개의 중첩된 열거형을 포함합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"블랙잭에서 에이스 카드의 값은 1 또는 11 입니다. 이러한 특징은 "},{"type":"codeVoice","code":"Rank"},{"type":"text","text":" 열거형 내에 중첩된 "},{"type":"codeVoice","code":"Values"},{"type":"text","text":" 라는 구조체로 나타냅니다:"}]},{"type":"codeListing","syntax":"swift","code":["struct BlackjackCard {","","    \/\/ nested Suit enumeration","    enum Suit: Character {","        case spades = \"♠\", hearts = \"♡\", diamonds = \"♢\", clubs = \"♣\"","    }","","    \/\/ nested Rank enumeration","    enum Rank: Int {","        case two = 2, three, four, five, six, seven, eight, nine, ten","        case jack, queen, king, ace","        struct Values {","            let first: Int, second: Int?","        }","        var values: Values {","            switch self {","            case .ace:","                return Values(first: 1, second: 11)","            case .jack, .queen, .king:","                return Values(first: 10, second: nil)","            default:","                return Values(first: self.rawValue, second: nil)","            }","        }","    }","","    \/\/ BlackjackCard properties and methods","    let rank: Rank, suit: Suit","    var description: String {","        var output = \"suit is \\(suit.rawValue),\"","        output += \" value is \\(rank.values.first)\"","        if let second = rank.values.second {","            output += \" or \\(second)\"","        }","        return output","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Suit"},{"type":"text","text":" 열거형은 기호를 나타내는 원시 "},{"type":"codeVoice","code":"Character"},{"type":"text","text":" 값과 함께 4개의 일반적인 카드 모양을 나타냅니다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Rank"},{"type":"text","text":" 열거형은 카드값을 나타내는 원시 "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 값과 함께 가능한 13개의 카드 순위를 나타냅니다 (이 원시 "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 값은 Jack, Queen, King, 그리고 Ace 카드에는 사용되지 않습니다)."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"위에서 말했듯이 "},{"type":"codeVoice","code":"Rank"},{"type":"text","text":" 열거형은 "},{"type":"codeVoice","code":"Values"},{"type":"text","text":" 라는 자신의 중첩된 구조체를 더 정의합니다. 이 구조체는 대부분의 카드는 하나의 값을 가지지만 에이스 카드는 2개의 값을 가지는 사실을 캡슐화 합니다. "},{"type":"codeVoice","code":"Values"},{"type":"text","text":" 구조체는 다음과 같이 2개의 프로퍼티를 정의합니다:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Int"},{"type":"text","text":" 타입의 "},{"type":"codeVoice","code":"first"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Int?"},{"type":"text","text":" 또는 “옵셔널 "},{"type":"codeVoice","code":"Int"},{"type":"text","text":"” 타입의 "},{"type":"codeVoice","code":"second"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Rank"},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"Values"},{"type":"text","text":" 구조체의 인스턴스를 반환하는 "},{"type":"codeVoice","code":"values"},{"type":"text","text":" 라는 계산된 프로퍼티도 정의합니다. 이 계산된 프로퍼티는 카드의 순위를 고려하고 그 순위를 기반으로 적절한 값으로 새로운 "},{"type":"codeVoice","code":"Values"},{"type":"text","text":" 인스턴스를 초기화 합니다. "},{"type":"codeVoice","code":"jack"},{"type":"text","text":", "},{"type":"codeVoice","code":"queen"},{"type":"text","text":", "},{"type":"codeVoice","code":"king"},{"type":"text","text":", 그리고 "},{"type":"codeVoice","code":"ace"},{"type":"text","text":" 에 대한 특별한 값을 사용합니다. 숫자 카드에 대해서는 순위의 원시 "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 값을 사용합니다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"BlackjackCard"},{"type":"text","text":" 구조체 자체는 "},{"type":"codeVoice","code":"rank"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"suit"},{"type":"text","text":" 의 2개의 프로퍼티를 가지고 있습니다. 이름과 카드의 값의 설명을 만들기 위해 "},{"type":"codeVoice","code":"rank"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"suit"},{"type":"text","text":" 에 저장된 값을 사용하는 "},{"type":"codeVoice","code":"description"},{"type":"text","text":" 이라는 계산된 프로퍼티도 정의합니다. "},{"type":"codeVoice","code":"description"},{"type":"text","text":" 프로퍼티는 화면에 표시하기 위해 두번째 값이 있는지 확인하고 있으면 두번째 값에 대해 상세 설명을 추가합니다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"BlackjackCard"},{"type":"text","text":" 는 사용자 지정 초기화 구문이 없는 구조체이기 때문에 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Initialization#%EA%B5%AC%EC%A1%B0%EC%B2%B4-%ED%83%80%EC%9E%85%EC%97%90-%EB%8C%80%ED%95%9C-%EB%A9%A4%EB%B2%84%EB%B3%84-%EC%B4%88%EA%B8%B0%ED%99%94-%EA%B5%AC%EB%AC%B8-Memberwise-Initializers-for-Structure-Types"},{"type":"text","text":" 에서 설명 했듯이 암시적 멤버별 초기화 구문을 가지고 있습니다. "},{"type":"codeVoice","code":"theAceOfSpades"},{"type":"text","text":" 라는 새로운 상수를 초기화 하기 위해 초기화 구문을 사용할 수 있습니다:"}]},{"type":"codeListing","syntax":"swift","code":["let theAceOfSpades = BlackjackCard(rank: .ace, suit: .spades)","print(\"theAceOfSpades: \\(theAceOfSpades.description)\")","\/\/ Prints \"theAceOfSpades: suit is ♠, value is 1 or 11\""]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Rank"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"Suit"},{"type":"text","text":" 은 "},{"type":"codeVoice","code":"BlackjackCard"},{"type":"text","text":" 내에 중첩되어 있지만 타입은 컨텍스트로 부터 유추될 수 있기 때문에 이 인스턴스의 초기화는 케이스 이름 ("},{"type":"codeVoice","code":".ace"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":".spades"},{"type":"text","text":") 만으로 열거형 케이스를 참조할 수 있습니다. 위의 예제에서 "},{"type":"codeVoice","code":"description"},{"type":"text","text":" 프로퍼티는 스페이드의 에이스는 "},{"type":"codeVoice","code":"1"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"11"},{"type":"text","text":" 의 값을 가지고 있다고 올바르게 보여줍니다."}]},{"anchor":"중첩된-타입-참조-Referring-to-Nested-Types","level":2,"type":"heading","text":"중첩된 타입 참조 (Referring to Nested Types)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"정의 컨텍스트 외부에서 중첩된 타입을 사용하기 위해 해당 이름에 중첩된 타입의 이름을 접두사로 붙입니다:"}]},{"type":"codeListing","syntax":"swift","code":["let heartsSymbol = BlackjackCard.Suit.hearts.rawValue","\/\/ heartsSymbol is \"♡\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"위의 예제에서 "},{"type":"codeVoice","code":"Suit"},{"type":"text","text":", "},{"type":"codeVoice","code":"Rank"},{"type":"text","text":" 그리고 "},{"type":"codeVoice","code":"Values"},{"type":"text","text":" 의 이름은 정의된 컨텍스트에 따라 자연스럽게 규정되기 때문에 의도적으로 짧게 유지할 수 있습니다."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"identifier":{"url":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/NestedTypes","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"타입의 범위안에 타입을 정의합니다."}],"kind":"article","metadata":{"title":"중첩된 타입 (Nested Types)"},"hierarchy":{"paths":[["doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean"]]},"references":{"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean":{"role":"collection","title":"The Swift Programming Language (한국어)","abstract":[],"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language-korean"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Initialization#%EA%B5%AC%EC%A1%B0%EC%B2%B4-%ED%83%80%EC%9E%85%EC%97%90-%EB%8C%80%ED%95%9C-%EB%A9%A4%EB%B2%84%EB%B3%84-%EC%B4%88%EA%B8%B0%ED%99%94-%EA%B5%AC%EB%AC%B8-Memberwise-Initializers-for-Structure-Types":{"abstract":[],"title":"구조체 타입에 대한 멤버별 초기화 구문 (Memberwise Initializers for Structure Types)","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Initialization#%EA%B5%AC%EC%A1%B0%EC%B2%B4-%ED%83%80%EC%9E%85%EC%97%90-%EB%8C%80%ED%95%9C-%EB%A9%A4%EB%B2%84%EB%B3%84-%EC%B4%88%EA%B8%B0%ED%99%94-%EA%B5%AC%EB%AC%B8-Memberwise-Initializers-for-Structure-Types","url":"\/documentation\/the-swift-programming-language-korean\/initialization#%25EA%25B5%25AC%25EC%25A1%25B0%25EC%25B2%25B4-%25ED%2583%2580%25EC%259E%2585%25EC%2597%2590-%25EB%258C%2580%25ED%2595%259C-%25EB%25A9%25A4%25EB%25B2%2584%25EB%25B3%2584-%25EC%25B4%2588%25EA%25B8%25B0%25ED%2599%2594-%25EA%25B5%25AC%25EB%25AC%25B8-Memberwise-Initializers-for-Structure-Types"}}}