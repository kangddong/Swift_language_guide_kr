{"primaryContentSections":[{"kind":"content","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift 에서 명명된 타입과 복합 타입의 두가지 종류가 있습니다. "},{"type":"emphasis","inlineContent":[{"type":"text","text":"명명된 타입 (named type)"}]},{"type":"text","text":" 은 정의될 때 특정 이름을 부여할 수 있는 타입입니다. 명명된 타입은 클래스, 구조체, 열거형, 그리고 프로토콜을 포함합니다. 예를 들어 "},{"type":"codeVoice","code":"MyClass"},{"type":"text","text":" 라는 사용자 정의 클래스의 인스턴스는 "},{"type":"codeVoice","code":"MyClass"},{"type":"text","text":" 타입을 가집니다. 사용자 정의 명명된 타입 외에도 Swift 표준 라이브러리는 배열, 딕셔너리, 그리고 옵셔널 값을 나타내는 타입을 포함하여 일반적으로 사용되는 명명된 타입을 정의합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"데이터 타입 (Data types) 은 다른 언어에서 일반적으로 기본 또는 원시라고 간주됩니다 — 숫자, 문자, 그리고 문자열을 나타내는 타입 — Swift 표준 라이브러리에서는 구조체를 사용하여 정의되고 구현된 타입입니다. 명명된 타입이므로 필요에 따라 프로그램에 맞게 적절하게 동작을 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Extensions"},{"type":"text","text":" 과 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%ED%99%95%EC%9E%A5-%EC%84%A0%EC%96%B8-Extension-Declaration"},{"type":"text","text":" 에서 설명된대로 확장 선언을 사용하여 확장할 수 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"복합 타입 (compound type)"}]},{"type":"text","text":" 은 Swift 언어 자체에 정의된 이름이 없는 타입입니다. 복합 타입은 함수 타입과 튜플 타입 두가지가 있습니다. 복합 타입은 명명된 타입과 다른 복합 타입을 포함할 수 있습니다. 예를 들어 튜플 타입 "},{"type":"codeVoice","code":"(Int, (Int, Int))"},{"type":"text","text":" 는 첫번째는 명명된 타입인 "},{"type":"codeVoice","code":"Int"},{"type":"text","text":", 두번째는 다른 복합 타입 "},{"type":"codeVoice","code":"(Int, Int)"},{"type":"text","text":" 인 두개의 요소가 포함됩니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"명명된 타입 또는 복합 타입을 묶을 소괄호를 넣을 수 있습니다. 그러나 타입을 묶은 소괄호는 아무런 영향을 주지 않습니다. 예를 들어 "},{"type":"codeVoice","code":"(Int)"},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 와 같습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 챕터에서는 Swift 언어 자체에 정의된 타입과 Swift 의 타입 추론에 대해 설명합니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"function-type"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"array-type"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"dictionary-type"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-identifier"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-type"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"optional-type"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"implicitly-unwrapped-optional-type"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol-composition-type"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"opaque-type"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"metatype-type"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"any-type"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"self-type"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"("}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":")"}]}]}],"type":"aside","name":"Grammar of a type"},{"anchor":"타입-주석-Type-Annotation","level":2,"type":"heading","text":"타입 주석 (Type Annotation)"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"타입 주석 (type annotation)"}]},{"type":"text","text":" 은 변수 또는 표현식의 타입을 명시적으로 지정합니다. 타입 주석은 아래 예제에서 보여주듯이 콜론 ("},{"type":"codeVoice","code":":"},{"type":"text","text":") 으로 시작하고 타입으로 끝납니다:"}]},{"type":"codeListing","syntax":"swift","code":["let someTuple: (Double, Double) = (3.14159, 2.71828)","func someFunction(a: Int) { \/* ... *\/ }"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"첫번째 예제에서 표현식 "},{"type":"codeVoice","code":"someTuple"},{"type":"text","text":" 은 튜플 타입 "},{"type":"codeVoice","code":"(Double, Double)"},{"type":"text","text":" 을 갖도록 지정됩니다. 두번째 예제는 함수 "},{"type":"codeVoice","code":"someFunction"},{"type":"text","text":" 에 파라미터 "},{"type":"codeVoice","code":"a"},{"type":"text","text":" 는 타입 "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 를 갖도록 지정합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"타입 주석은 타입 앞에 타입 속성의 옵셔널 리스트을 포함할 수 있습니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type-annotation"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":":"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"attributes"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"inout"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]}]}],"type":"aside","name":"Grammar of a type annotation"},{"anchor":"타입-식별자-Type-Identifier","level":2,"type":"heading","text":"타입 식별자 (Type Identifier)"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"타입 식별자 (type identifier)"}]},{"type":"text","text":" 는 명명된 타입 또는 명명된 타입 또는 복합 타입의 타입 별칭 (type alias) 을 나타냅니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"대부분의 경우 타입 식별자는 식별자로 같은 이름의 명명된 타입을 직접 참조합니다. 예를 들어 "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 는 명명된 타입 "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 를 직접 참조하는 타입 식별자이고 타입 식별자 "},{"type":"codeVoice","code":"Dictionary<String, Int>"},{"type":"text","text":" 는 명명된 타입 "},{"type":"codeVoice","code":"Dictionary<String, Int>"},{"type":"text","text":" 를 직접 참조합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"타입 식별자가 동일한 이름의 타입을 참조하지 않는 두가지 경우가 있습니다. 첫번째는 타입 식별자는 명명된 타입 또는 복합 타입의 타입 별칭을 나타냅니다. 예를 들어 아래 예제에서 타입 주석에서 "},{"type":"codeVoice","code":"Point"},{"type":"text","text":" 의 사용은 튜플 타입 "},{"type":"codeVoice","code":"(Int, Int)"},{"type":"text","text":" 를 나타냅니다."}]},{"type":"codeListing","syntax":"swift","code":["typealias Point = (Int, Int)","let origin: Point = (0, 0)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"두번째 경우 타입 식별자는 다른 모듈에서 선언되거나 다른 타입 내에 중첩된 명명된 타입을 참조하기 위해 점 ("},{"type":"codeVoice","code":"."},{"type":"text","text":") 구문을 사용합니다. 예를 들어 다음 코드의 타입 식별자는 "},{"type":"codeVoice","code":"ExampleModule"},{"type":"text","text":" 모듈에 선언된 명명된 타입 "},{"type":"codeVoice","code":"MyType"},{"type":"text","text":" 을 참조합니다."}]},{"type":"codeListing","syntax":"swift","code":["var someValue: ExampleModule.MyType"]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type-identifier"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-name"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"generic-argument-clause"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-name"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"generic-argument-clause"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"."}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-identifier"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type-name"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier"}]}]}],"type":"aside","name":"Grammar of a type identifier"},{"anchor":"튜플-타입-Tuple-Type","level":2,"type":"heading","text":"튜플 타입 (Tuple Type)"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"튜플 타입 (tuple type)"}]},{"type":"text","text":" 은 소괄호로 묶인 콤마로 구분된 타입의 리스트입니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"튜플 타입을 함수의 반환 타입으로 사용하여 함수가 여러값을 포함하는 단일 튜플을 반환하도록 할 수 있습니다. 튜플 타입의 요소에 이름을 지정하고 해당 이름을 사용하여 개별 요소의 값을 참조할 수도 있습니다. 요소 이름은 바로 뒤에 콜론 ("},{"type":"codeVoice","code":":"},{"type":"text","text":") 이 오는 식별자로 구성됩니다. 이러한 기능을 보여주는 예제는 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions#%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-%EB%B0%98%ED%99%98%EA%B0%92%EC%9D%B4-%EC%9E%88%EB%8A%94-%ED%95%A8%EC%88%98-Functions-with-Multiple-Return-Values"},{"type":"text","text":" 를 참고 바랍니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"튜플 타입의 요소가 이름을 가지는 경우 이름은 타입의 부분입니다."}]},{"type":"codeListing","syntax":"swift","code":["var someTuple = (top: 10, bottom: 12)  \/\/ someTuple is of type (top: Int, bottom: Int)","someTuple = (top: 4, bottom: 42) \/\/ OK: names match","someTuple = (9, 99)              \/\/ OK: names are inferred","someTuple = (left: 5, right: 5)  \/\/ Error: names don't match"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"모든 튜플 타입은 빈 튜플 타입 인 "},{"type":"codeVoice","code":"()"},{"type":"text","text":" 에 대한 타입 별칭인 "},{"type":"codeVoice","code":"Void"},{"type":"text","text":" 를 제외하고 두 개 이상의 타입을 포함합니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-type"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"("}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":")"}]},{"type":"text","text":" | "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"("}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-type-element"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":","}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-type-element-list"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":")"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-type-element-list"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-type-element"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-type-element"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":","}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-type-element-list"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-type-element"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"element-name"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-annotation"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"element-name"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier"}]}]}],"type":"aside","name":"Grammar of a tuple type"},{"anchor":"함수-타입-Function-Type","level":2,"type":"heading","text":"함수 타입 (Function Type)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"함수 타입 (function type) 은 함수, 메서드, 또는 클로저의 타입을 나타내고 화살표 ("},{"type":"codeVoice","code":"->"},{"type":"text","text":") 로 구분된 파라미터와 반환 타입으로 구성됩니다:"}]},{"type":"codeListing","syntax":"swift","code":["(<#parameter type#>) -> <#return type#>"]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"파라미터 타입 (parameter type)"}]},{"type":"text","text":" 은 콤마로 구분된 타입의 리스트입니다. "},{"type":"emphasis","inlineContent":[{"type":"text","text":"반환 타입 (return type)"}]},{"type":"text","text":" 은 튜플 타입일 수 있기 때문에 함수 타입은 여러값을 반환하는 함수와 메서드를 지원합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"함수 타입 "},{"type":"codeVoice","code":"() -> T"},{"type":"text","text":" (여기서 "},{"type":"codeVoice","code":"T"},{"type":"text","text":" 는 모든 타입) 의 파라미터는 "},{"type":"codeVoice","code":"autoclosure"},{"type":"text","text":" 속성을 적용하여 호출 부분에서 암시적으로 클로저를 생성할 수 있습니다. 이것은 함수를 호출할 때 명시적으로 클로저를 작성할 필요없이 표현식의 평가를 연기하는 구문상 편리함을 제공합니다. 자동 클로저 함수 타입 파라미터의 예제는 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Closures#%EC%9E%90%EB%8F%99-%ED%81%B4%EB%A1%9C%EC%A0%80-Autoclosures"},{"type":"text","text":" 를 참고 바랍니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"함수 타입은 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"파라미터 타입"}]},{"type":"text","text":" 에 가변 파라미터 (variadic parameters) 를 가질 수 있습니다. 구문적으로 가변 파라미터는 "},{"type":"codeVoice","code":"Int..."},{"type":"text","text":" 와 같이 기본 타입 이름과 바로 뒤에 점 3개 ("},{"type":"codeVoice","code":"..."},{"type":"text","text":") 로 구성됩니다. 가변 파라미터는 기본 타입 이름의 요소를 포함하는 배열로 처리됩니다. 예를 들어 가변 파라미터 "},{"type":"codeVoice","code":"Int..."},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"[Int]"},{"type":"text","text":" 로 처리됩니다. 가변 파라미터를 사용하는 예제는 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions#%EA%B0%80%EB%B3%80-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-Variadic-Parameters"},{"type":"text","text":" 를 참고 바랍니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"in-out 파라미터 (in-out parameter) 를 지정하려면 "},{"type":"codeVoice","code":"inout"},{"type":"text","text":" 키워드를 파라미터 타입 앞에 붙여야 합니다. "},{"type":"codeVoice","code":"inout"},{"type":"text","text":" 키워드로 가변 파라미터나 반환 타입으로 표시할 수 없습니다. In-out 파라미터는 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions#In-Out-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-In-Out-Parameters"},{"type":"text","text":" 에 설명되어 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"함수 타입에 파라미터가 하나만 가지고 있고 파라미터 타입이 튜플 타입인 경우 함수 타입을 작성할 때 튜플 타입을 괄호로 묶어야 합니다. 예를 들어 "},{"type":"codeVoice","code":"((Int, Int)) -> Void"},{"type":"text","text":" 는 튜플 타입 "},{"type":"codeVoice","code":"(Int, Int)"},{"type":"text","text":" 의 단일 파라미터를 가지고 값을 반환하지 않는 함수 타입입니다. 반대로 괄호가 없으면 "},{"type":"codeVoice","code":"(Int, Int) -> Void"},{"type":"text","text":" 는 두 개의 "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 파라미터를 가지고 값을 반환하지 않는 함수 타입입니다. 마찬가지로 "},{"type":"codeVoice","code":"Void"},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"()"},{"type":"text","text":" 에 대한 타입 별칭 이므로 함수 타입 "},{"type":"codeVoice","code":"(Void) -> Void"},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"(()) -> ()"},{"type":"text","text":" 와 같습니다—빈 튜플인 단일 인수를 가지는 함수와 같습니다. 이 타입은 "},{"type":"codeVoice","code":"() -> ()"},{"type":"text","text":" 와 같지 않습니다 — 인수를 가지지 않는 함수입니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"함수와 메서드에 인수 이름은 해당 함수 타입의 일부가 아닙니다. 예를 들어:"}]},{"type":"codeListing","syntax":"swift","code":["func someFunction(left: Int, right: Int) {}","func anotherFunction(left: Int, right: Int) {}","func functionWithDifferentLabels(top: Int, bottom: Int) {}","","var f = someFunction \/\/ The type of f is (Int, Int) -> Void, not (left: Int, right: Int) -> Void.","f = anotherFunction              \/\/ OK","f = functionWithDifferentLabels  \/\/ OK","","func functionWithDifferentArgumentTypes(left: Int, right: String) {}","f = functionWithDifferentArgumentTypes     \/\/ Error","","func functionWithDifferentNumberOfArguments(left: Int, right: Int, top: Int) {}","f = functionWithDifferentNumberOfArguments \/\/ Error"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"인수 라벨은 함수 타입의 일부분이 아니므로 함수 타입을 작성할 때 생략합니다."}]},{"type":"codeListing","syntax":"swift","code":["var operation: (lhs: Int, rhs: Int) -> Int     \/\/ Error","var operation: (_ lhs: Int, _ rhs: Int) -> Int \/\/ OK","var operation: (Int, Int) -> Int               \/\/ OK"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"함수 타입에 하나 이상의 화살표 ("},{"type":"codeVoice","code":"->"},{"type":"text","text":") 를 포함하는 경우 함수 타입은 오른쪽에서 왼쪽으로 그룹화 됩니다. 예를 들어 함수 타입 "},{"type":"codeVoice","code":"(Int) -> (Int) -> Int"},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"(Int) -> ((Int) -> Int)"},{"type":"text","text":" 로 이해됩니다 — 이 함수는 "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 를 가지며 "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 를 가지고 반환하는 다른 함수를 반환합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"에러를 발생 시키거나 다시 발생 시킬 수 있는 함수에 대한 함수 타입은 "},{"type":"codeVoice","code":"throws"},{"type":"text","text":" 키워드로 표시되어야 합니다. "},{"type":"codeVoice","code":"throws"},{"type":"text","text":" 키워드는 함수 타입의 일부분이며 던지지 않는 함수 (nonthrowing functions) 는 던지는 함수 (throwing functions) 의 하위 타입 (subtypes) 입니다. 결과적으로 던지는 함수로 같은 위치에서 던지지 않는 함수를 사용할 수 있습니다. 던지는 함수와 던지지 않는 함수는 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-%EB%8D%98%EC%A7%80%EA%B8%B0-Throwing-Functions-and-Methods"},{"type":"text","text":" 와 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%EB%8B%A4%EC%8B%9C-%EB%8D%98%EC%A7%80%EB%8A%94-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-Rethrowing-Functions-and-Methods"},{"type":"text","text":" 에 설명되어 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"비동기 함수에 대한 함수 타입은 "},{"type":"codeVoice","code":"async"},{"type":"text","text":" 키워드로 표시되어야 합니다. "},{"type":"codeVoice","code":"async"},{"type":"text","text":" 키워드는 함수의 타입의 부분이며, 동기 함수는 비동기 함수의 하위 타입 (subtypes) 입니다. 결과적으로 비동기 함수와 같은 위치에서 동기 함수를 사용할 수 있습니다. 비동기 함수에 대한 더 자세한 설명은 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-Asynchronous-Functions-and-Methods"},{"type":"text","text":" 를 참고 바랍니다."}]},{"anchor":"비탈출-클로저에-대한-제한사항-Restrictions-for-Nonescaping-Closures","level":3,"type":"heading","text":"비탈출 클로저에 대한 제한사항 (Restrictions for Nonescaping Closures)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"비탈출 함수 (nonescaping function) 인 파라미터는 값이 탈출 될 수 있으므로 타입 "},{"type":"codeVoice","code":"Any"},{"type":"text","text":" 의 프로퍼티, 변수, 또는 상수에 저장될 수 없습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"비탈출 함수 인 파라미터는 다른 비탈출 함수 파라미터 인수로 전달될 수 없습니다. 이 제한사항은 Swift 가 런타임이 아닌 컴파일 시 메모리에 접근 충돌에 대한 검사를 더 많이 수행하는데 도움이 됩니다. 예를 들어:"}]},{"type":"codeListing","syntax":"swift","code":["let external: (() -> Void) -> Void = { _ in () }","func takesTwoFunctions(first: (() -> Void) -> Void, second: (() -> Void) -> Void) {","    first { first {} }       \/\/ Error","    second { second {}  }    \/\/ Error","","    first { second {} }      \/\/ Error","    second { first {} }      \/\/ Error","","    first { external {} }    \/\/ OK","    external { first {} }    \/\/ OK","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"위의 코드에서 "},{"type":"codeVoice","code":"takesTwoFunctions(first:second:)"},{"type":"text","text":" 에 대한 두 파라미터는 모두 함수입니다. 두 파라미터 모두 "},{"type":"codeVoice","code":"@escaping"},{"type":"text","text":" 으로 표시되지 않으므로 결과적으로 둘다 비탈출 입니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"위의 예제에서 “Error” 로 표시된 4개의 함수 호출은 컴파일러 에러를 일으킵니다. "},{"type":"codeVoice","code":"first"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"second"},{"type":"text","text":" 파라미터는 비탈출 함수이므로 다른 비탈출 함수 파라미터 인수로 전달될 수 없습니다. 반대로 “OK” 로 표시된 2개의 함수 호출은 컴파일러 에러를 발생시키지 않습니다. 이 함수 호출은 "},{"type":"codeVoice","code":"external"},{"type":"text","text":" 이 "},{"type":"codeVoice","code":"takesTwoFunctions(first:second:)"},{"type":"text","text":" 의 파라미터 중 하나가 아니므로 제한사항에 위배되지 않습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"제한사항을 피해야 하는 경우 파라미터 중 하나를 탈출로 표시하거나 "},{"type":"codeVoice","code":"withoutActuallyEscaping(_:do:)"},{"type":"text","text":" 함수를 이용하여 탈출 함수로 비탈출 함수 파라미터 중 하나를 임시로 변경해야 합니다. 메모리에 충돌 접근을 피하는 것에 대한 자세한 내용은 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/MemorySafety"},{"type":"text","text":" 을 참고 바랍니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"function-type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"attributes"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"function-type-argument-clause"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"async"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"throws"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"->"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"function-type-argument-clause"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"("}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":")"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"function-type-argument-clause"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"("}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"function-type-argument-list"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"..."}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":")"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"function-type-argument-list"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"function-type-argument"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"function-type-argument"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":","}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"function-type-argument-list"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"function-type-argument"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"attributes"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"inout"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"argument-label"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-annotation"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"argument-label"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier"}]}]}],"type":"aside","name":"Grammar of a function type"},{"anchor":"배열-타입-Array-Type","level":2,"type":"heading","text":"배열 타입 (Array Type)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift 언어는 Swift 표준 라이브러리 "},{"type":"codeVoice","code":"Array<Element>"},{"type":"text","text":" 타입에 대해 다음과 같은 구문을 제공합니다:"}]},{"type":"codeListing","syntax":"swift","code":["[<#type#>]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"다른 표현으로 다음의 두 선언도 동일합니다:"}]},{"type":"codeListing","syntax":"swift","code":["let someArray: Array<String> = [\"Alex\", \"Brian\", \"Dave\"]","let someArray: [String] = [\"Alex\", \"Brian\", \"Dave\"]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"두 경우 모두 상수 someArray 는 문자열의 배열로 선언됩니다. 배열의 요소는 대괄호에 유효한 인덱스 값을 지정하여 서브 스크립트를 통해 접근할 수 있습니다: "},{"type":"codeVoice","code":"someArray[0]"},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"\"Alex\""},{"type":"text","text":" 인 인덱스 0번째 요소를 나타냅니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"대괄호 쌍을 중첩하여 다차원 배열을 만들 수 있습니다. 여기서 요소의 기본 타입 이름은 가장 안쪽 대괄호 쌍에 포함됩니다. 예를 들어 대괄호 3쌍을 이용하여 정수의 3차원 배열을 생성할 수 있습니다:"}]},{"type":"codeListing","syntax":"swift","code":["var array3D: [[[Int]]] = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"다차원 배열의 요소에 접근할 때 가장 왼쪽에 있는 서브 스크립트 인덱스는 배열의 가장 바깥 쪽에 있는 요소를 참조합니다. 오른쪽에 있는 다음 서브 스크립트 인덱스는 한 차원 더 들어가는 중첩된 배열의 요소를 참조합니다. 이것은 위의 예제에서 "},{"type":"codeVoice","code":"array3D[0]"},{"type":"text","text":" 은 "},{"type":"codeVoice","code":"[[1, 2], [3, 4]]"},{"type":"text","text":" 를 참조하고 "},{"type":"codeVoice","code":"array3D[0][1]"},{"type":"text","text":" 은 "},{"type":"codeVoice","code":"[3, 4]"},{"type":"text","text":" 그리고 "},{"type":"codeVoice","code":"array3D[0][1][1]"},{"type":"text","text":" 은 값 4를 참조합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift 표준 라이브러리 "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" 타입에 대한 자세한 설명은 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/CollectionTypes#%EB%B0%B0%EC%97%B4-Arrays"},{"type":"text","text":" 을 참고 바랍니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"array-type"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"["}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"]"}]}]}],"type":"aside","name":"Grammar of an array type"},{"anchor":"딕셔너리-타입-Dictionary-Type","level":2,"type":"heading","text":"딕셔너리 타입 (Dictionary Type)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift 언어는 Swift 표준 라이브러리 "},{"type":"codeVoice","code":"Dictionary<Key, Value>"},{"type":"text","text":" 타입에 대해 아래와 같은 구문을 제공합니다:"}]},{"type":"codeListing","syntax":"swift","code":["[<#key type#>: <#value type#>]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"다른 표현으로 다음의 두 선언도 동일합니다:"}]},{"type":"codeListing","syntax":"swift","code":["let someDictionary: [String: Int] = [\"Alex\": 31, \"Paul\": 39]","let someDictionary: Dictionary<String, Int> = [\"Alex\": 31, \"Paul\": 39]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"두 경우 모두 상수 "},{"type":"codeVoice","code":"someDictionary"},{"type":"text","text":" 는 키로 문자열과 값으로 정수를 가지는 딕셔너리가 선언됩니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"딕셔너리의 값은 대괄호에 해당 키를 지정하여 접근할 수 있습니다: "},{"type":"codeVoice","code":"someDictionary[\"Alex\"]"},{"type":"text","text":" 는 키 "},{"type":"codeVoice","code":"\"Alex\""},{"type":"text","text":" 와 연관된 값을 참조합니다. 서브 스크립트는 딕셔너리의 값 타입의 옵셔널 값을 반환합니다. 지정한 키가 딕셔너리에 포함되지 않은 경우 서브 스크립트는 "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" 을 반환합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"딕셔너리의 키 타입은 Swift 표준 라이브러리 "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" 프로토콜을 준수해야 합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift 표준 라이브러리 "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" 타입의 자세한 설명은 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/CollectionTypes#%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC-Dictionaries"},{"type":"text","text":" 를 참고 바랍니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"dictionary-type"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"["}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":":"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"]"}]}]}],"type":"aside","name":"Grammar of a dictionary type"},{"anchor":"옵셔널-타입-Optional-Type","level":2,"type":"heading","text":"옵셔널 타입 (Optional Type)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift 언어는 Swift 표준 라이브러리에 정의된 명명된 타입 "},{"type":"codeVoice","code":"Optional<Wrapped>"},{"type":"text","text":" 에 대해 접미사 "},{"type":"codeVoice","code":"?"},{"type":"text","text":" 구문을 정의합니다. 다른 표현으로 다음의 두 선언은 동일합니다:"}]},{"type":"codeListing","syntax":"swift","code":["var optionalInteger: Int?","var optionalInteger: Optional<Int>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"두 경우 모두 변수 "},{"type":"codeVoice","code":"optionalInteger"},{"type":"text","text":" 는 옵셔널 정수의 타입을 가지도록 선언됩니다. 타입과 "},{"type":"codeVoice","code":"?"},{"type":"text","text":" 사이에는 공백이 없을 수도 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"타입 "},{"type":"codeVoice","code":"Optional<Wrapped>"},{"type":"text","text":" 는 존재하거나 존재하지 않을 수 있는 값을 나타내는데 "},{"type":"codeVoice","code":"none"},{"type":"text","text":" 과 "},{"type":"codeVoice","code":"some(Wrapped)"},{"type":"text","text":" 의 두가지 케이스가 있는 열거형입니다. 모든 타입은 명시적으로 선언되거나 옵셔널 타입으로 암시적으로 변환될 수 있습니다. 옵셔널 변수 또는 프로퍼티를 선언할 때 초기값을 제공하지 않으면 자동으로 "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" 로 설정합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"옵셔널 타입의 인스턴스는 값을 포함할 경우 아래에서 보듯이 접시마 연산자 "},{"type":"codeVoice","code":"!"},{"type":"text","text":" 를 사용하여 값에 접근할 수 있습니다:"}]},{"type":"codeListing","syntax":"swift","code":["optionalInteger = 42","optionalInteger! \/\/ 42"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"nil"},{"type":"text","text":" 의 값을 가지는 옵셔널을 언래핑 하기위해 "},{"type":"codeVoice","code":"!"},{"type":"text","text":" 연산자를 사용하면 런타임 에러가 발생합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"옵셔널 표현식에 대해 조건부 수행을 위해 옵셔널 체이닝과 옵셔널 바인딩을 사용할 수도 있습니다. 값이 "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" 인 경우에 작업은 더이상 수행되지 않으므로 런타임 에러가 발생하지 않습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"더 자세한 정보와 옵셔널 타입 사용에 대한 예제를 보려면 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TheBasics#%EC%98%B5%EC%85%94%EB%84%90-Optionals"},{"type":"text","text":" 을 참고 바랍니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"optional-type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"?"}]}]}],"type":"aside","name":"Grammar of an optional type"},{"anchor":"암시적으로-언래핑된-옵셔널-타입-Implicitly-Unwrapped-Optional-Type","level":2,"type":"heading","text":"암시적으로 언래핑된 옵셔널 타입 (Implicitly Unwrapped Optional Type)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift 언어는 옵셔널 타입에 접근할 때 자동으로 언래핑된 동작을 추가하기 위해 Swift 표준 라이브러리에 정의된 명명된 타입 "},{"type":"codeVoice","code":"Optional<Wrapped>"},{"type":"text","text":" 에 대한 접미사 "},{"type":"codeVoice","code":"!"},{"type":"text","text":" 구문을 정의합니다. "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" 의 값을 가지는 옵셔널에 암시적 언래핑을 사용하려고 하면 런타임 에러가 발생합니다. 암시적 언래핑 동작을 제외하고 다음의 두 선언은 동일합니다:"}]},{"type":"codeListing","syntax":"swift","code":["var implicitlyUnwrappedString: String!","var explicitlyUnwrappedString: Optional<String>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"타입과 "},{"type":"codeVoice","code":"!"},{"type":"text","text":" 사이에 공백이 포함되지 않을 수 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"암시적 언래핑은 해당 타입을 포함하는 선언의 의미를 변경하기 때문에 튜플 타입 또는 딕셔너리 또는 배열의 요소 타입과 같이 제너릭 타입 내에 중첩된 옵셔널 타입은 암시적 언래핑으로 표시할 수 없습니다. 예를 들어:"}]},{"type":"codeListing","syntax":"swift","code":["let tupleOfImplicitlyUnwrappedElements: (Int!, Int!)  \/\/ Error","let implicitlyUnwrappedTuple: (Int, Int)!             \/\/ OK","","let arrayOfImplicitlyUnwrappedElements: [Int!]        \/\/ Error","let implicitlyUnwrappedArray: [Int]!                  \/\/ OK"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"암시적으로 언래핑된 옵셔널은 옵셔널 값과 동일한 "},{"type":"codeVoice","code":"Optional<Wrapped>"},{"type":"text","text":" 타입을 가지므로 옵셔널을 사용할 수 있는 코드에서 동일한 위치에서 암시적으로 언래핑된 옵셔널을 사용할 수 있습니다. 예를 들어 옵셔널의 변수, 상수, 그리고 프로퍼티에 암시적으로 언래핑된 옵셔널의 값을 할당할 수 있고 그 반대도 가능합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"옵셔널과 마찬가지로 암시적으로 언래핑된 옵셔널 변수 또는 프로퍼티를 선언할 때 초기값을 제공하지 않으면 자동으로 "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" 을 기본값으로 설정합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"암시적으로 언래핑된 옵셔널 표현식에 조건부로 동작을 수행하려면 옵셔널 체이닝을 사용합니다. 값이 "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" 이라면 더이상 작업이 수행되지 않으며 런타임 에러가 발생하지 않습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"암시적으로 언래핑된 옵셔널 타입에 대한 자세한 정보는 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TheBasics#%EC%95%94%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%96%B8%EB%9E%98%ED%95%91%EB%90%9C-%EC%98%B5%EC%85%94%EB%84%90-Implicitly-Unwrapped-Optionals"},{"type":"text","text":" 을 참고 바랍니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"implicitly-unwrapped-optional-type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"!"}]}]}],"type":"aside","name":"Grammar of an implicitly unwrapped optional type"},{"anchor":"프로토콜-혼합-타입-Protocol-Composition-Type","level":2,"type":"heading","text":"프로토콜 혼합 타입 (Protocol Composition Type)"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"프로토콜 혼합 타입 (protocol composition type)"}]},{"type":"text","text":" 은 지정된 프로토콜의 리스트에서 각 프로토콜을 준수하는 타입 또는 주어진 클래스의 하위 클래스와 지정된 프로토콜의 리스트애서 각 프로토콜을 준수하는 타입을 정의합니다. 프로토콜 혼합 타입은 타입 주석, 제너릭 파라미터 절, 그리고 제너릭 "},{"type":"codeVoice","code":"where"},{"type":"text","text":" 절을 지정할 때만 사용할 수 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"프로토콜 혼합 타입은 다음의 형식을 가집니다:"}]},{"type":"codeListing","syntax":"swift","code":["<#Protocol 1#> & <#Protocol 2#>"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"프로토콜 혼합 타입을 사용하면 타입이 준수하려는 각 프로토콜에서 상속되는 명명된 프로토콜을 새롭게 명시적으로 정의하지 않아도 타입이 여러 프로토콜의 요구사항을 준수하는 값을 지정할 수 있습니다. 예를 들어 "},{"type":"codeVoice","code":"ProtocolA"},{"type":"text","text":", "},{"type":"codeVoice","code":"ProtocolB"},{"type":"text","text":", 그리고 "},{"type":"codeVoice","code":"ProtocolC"},{"type":"text","text":" 를 상속하는 새로운 프로토콜을 선언하는 대신 프로토콜 혼합 타입 "},{"type":"codeVoice","code":"ProtocolA & ProtocolB & ProtocolC"},{"type":"text","text":" 를 사용할 수 있습니다. 마찬가지로 "},{"type":"codeVoice","code":"SuperClass"},{"type":"text","text":" 의 하위 클래스와 "},{"type":"codeVoice","code":"ProtocolA"},{"type":"text","text":" 를 준수하는 새로운 프로토콜을 선언하는 대신에 "},{"type":"codeVoice","code":"SuperClass & ProtocolA"},{"type":"text","text":" 를 사용할 수 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"프로토콜 혼합 리스트에 각 항목은 다음 중 하나입니다; 이 리스트는 최대 하나의 클래스를 포함할 수 있습니다:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"클래스의 이름"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"프로토콜의 이름"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"기본 타입이 프로토콜 구성 타입, 프로토콜, 또는 클래스 인 타입 별칭"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"프로토콜 혼합 타입이 타입 별칭을 포함할 때 동일한 프로토콜이 정의에 중복해서 나타날 수 있으며 중복은 무시됩니다. 예를 들어 아래 코드에서 "},{"type":"codeVoice","code":"PQR"},{"type":"text","text":" 의 정의는 "},{"type":"codeVoice","code":"P & Q & R"},{"type":"text","text":" 과 동일합니다."}]},{"type":"codeListing","syntax":"swift","code":["typealias PQ = P & Q","typealias PQR = PQ & Q & R"]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol-composition-type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-identifier"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"&"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol-composition-continuation"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol-composition-continuation"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-identifier"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol-composition-type"}]}]}],"type":"aside","name":"Grammar of a protocol composition type"},{"anchor":"불투명한-타입-Opaque-Type","level":2,"type":"heading","text":"불투명한 타입 (Opaque Type)"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"불투명한 타입 (opaque type)"}]},{"type":"text","text":" 은 기본 타입 지정없이 프로토콜 또는 프로토콜 구성을 준수하는 타입을 정의합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"불투명한 타입은 함수 또는 서브 스크립트의 반환타입 또는 프로퍼티의 타입으로 나타납니다. 불투명한 타입은 배열의 요소 타입 또는 옵셔널의 래핑된 타입과 같은 튜플 타입 또는 제너릭 타입의 부분으로 나타날 수 없습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"불투명 타입은 다음의 형식을 가집니다:"}]},{"type":"codeListing","syntax":"swift","code":["some <#constraint#>"]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"제약조건 (constraint)"}]},{"type":"text","text":" 은 클래스 타입, 프로토콜 타입, 프로토콜 구성 타입, 또는 "},{"type":"codeVoice","code":"Any"},{"type":"text","text":" 입니다. 값은 나열된 프로토콜 또는 프로토콜 구성을 준수하는 타입의 인스턴스나 나열된 클래스를 상속하는 경우에만 불투명한 타입의 인스턴스로 사용될 수 있습니다. 불투명한 값과 상호작용하는 코드는 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"제약조건 (constraint)"}]},{"type":"text","text":" 에 의해 정의된 인터페이스의 일부의 방식으로만 값으로 사용할 수 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"프로토콜 선언은 불투명한 타입을 포함할 수 없습니다. 클래스는 비final 메서드 (nonfinal method) 의 반환 타입으로 불투명한 타입을 사용할 수 없습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"불투명한 타입을 반환 타입으로 사용하는 함수는 단일 기본 타입을 공유하는 값을 반환해야 합니다. 반환 타입은 함수의 제너릭 타입 파라미터의 부분인 타입을 포함할 수 있습니다. 예를 들어 함수 "},{"type":"codeVoice","code":"someFunction<T>()"},{"type":"text","text":" 는 타입 "},{"type":"codeVoice","code":"T"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"Dictionary<String, T>"},{"type":"text","text":" 의 값을 반환할 수 있습니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"opaque-type"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"some"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]}]}],"type":"aside","name":"Grammar of an opaque type"},{"anchor":"메타타입-타입-Metatype-Type","level":2,"type":"heading","text":"메타타입 타입 (Metatype Type)"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"메타타입 타입 (metatype type)"}]},{"type":"text","text":" 은 클래스 타입, 구조체 타입, 열거형 타입, 그리고 프로토콜 타입을 포함하여 모든 타입의 타입을 나타냅니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"클래스, 구조체, 또는 열거형 타입의 메타타입은 해당 타입의 이름 다음에 "},{"type":"codeVoice","code":".Type"},{"type":"text","text":" 을 붙입니다. 런타임 시 프로토콜을 준수하는 구체적인 타입이 아닌 프로토콜 타입의 메타타입은 프로토콜의 이름 다음에 "},{"type":"codeVoice","code":".Protocol"},{"type":"text","text":" 을 붙입니다. 예를 들어 클래스 타입 "},{"type":"codeVoice","code":"SomeClass"},{"type":"text","text":" 의 메타타입은 "},{"type":"codeVoice","code":"SomeClass.Type"},{"type":"text","text":" 그리고 프로토콜 "},{"type":"codeVoice","code":"SomeProtocol"},{"type":"text","text":" 의 메타타입은 "},{"type":"codeVoice","code":"SomeProtocol.Protocol"},{"type":"text","text":" 입니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"접미사 "},{"type":"codeVoice","code":"self"},{"type":"text","text":" 표현식을 사용하여 타입을 값으로 접근할 수 있습니다. 예를 들어 "},{"type":"codeVoice","code":"SomeClass.self"},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"SomeClass"},{"type":"text","text":" 의 인스턴스가 아닌 "},{"type":"codeVoice","code":"SomeClass"},{"type":"text","text":" 자체를 반환합니다. 그리고 "},{"type":"codeVoice","code":"SomeProtocol.self"},{"type":"text","text":" 는 런타임 시 "},{"type":"codeVoice","code":"SomeProtocol"},{"type":"text","text":" 을 준수하는 타입의 인스턴스가 아닌 "},{"type":"codeVoice","code":"SomeProtocol"},{"type":"text","text":" 자체를 반환합니다. 다음 예제와 같이 타입의 인스턴스와 함께 "},{"type":"codeVoice","code":"type(of:)"},{"type":"text","text":" 함수를 호출하여 해당 인스턴스의 동적으로 런타임 타입의 값으로 접근할 수 있습니다:"}]},{"type":"codeListing","syntax":"swift","code":["class SomeBaseClass {","    class func printClassName() {","        print(\"SomeBaseClass\")","    }","}","class SomeSubClass: SomeBaseClass {","    override class func printClassName() {","        print(\"SomeSubClass\")","    }","}","let someInstance: SomeBaseClass = SomeSubClass()","\/\/ The compile-time type of someInstance is SomeBaseClass,","\/\/ and the runtime type of someInstance is SomeSubClass","type(of: someInstance).printClassName()","\/\/ Prints \"SomeSubClass\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"자세한 내용은 Swift 표준 라이브러리에 "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/2885064-type"},{"type":"text","text":" 을 참고 바랍니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"초기화 구문 표현식을 사용하여 해당 타입의 메타타입 값에서 타입의 인스턴스를 생성합니다. 클래스 인스턴스의 경우 호출되는 초기화 구문은 "},{"type":"codeVoice","code":"required"},{"type":"text","text":" 키워드로 표시거나 "},{"type":"codeVoice","code":"final"},{"type":"text","text":" 키워드로 전체 클래스를 표시해야 합니다."}]},{"type":"codeListing","syntax":"swift","code":["class AnotherSubClass: SomeBaseClass {","    let string: String","    required init(string: String) {","        self.string = string","    }","    override class func printClassName() {","        print(\"AnotherSubClass\")","    }","}","let metatype: AnotherSubClass.Type = AnotherSubClass.self","let anotherInstance = metatype.init(string: \"some string\")"]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"metatype-type"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"."}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"Type"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"."}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"Protocol"}]}]}],"type":"aside","name":"Grammar of a metatype type"},{"anchor":"Any-타입-Any-Type","level":2,"type":"heading","text":"Any 타입 (Any Type)"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Any"},{"type":"text","text":" 타입은 다른 모든 타입의 값을 포함할 수 있습니다. "},{"type":"codeVoice","code":"Any"},{"type":"text","text":" 는 다음 타입의 인스턴스에 대해 구체적인 타입으로 사용될 수 있습니다:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"클래스, 구조체, 또는 열거형"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Int.self"},{"type":"text","text":" 와 같은 메타타입"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"모든 타입의 구성요소가 있는 튜플"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"클로저 또는 함수 타입"}]}]}]},{"type":"codeListing","syntax":"swift","code":["let mixed: [Any] = [\"one\", 2, true, (4, 5.3), { () -> Int in return 6 }]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"인스턴스에 대해 구체적인 타입으로 "},{"type":"codeVoice","code":"Any"},{"type":"text","text":" 를 사용할 때 해당 프로퍼티 또는 메서드에 접근하려면 먼저 알려진 타입으로 인스턴스를 캐스팅 해야 합니다. "},{"type":"codeVoice","code":"Any"},{"type":"text","text":" 의 구체적인 타입인 인스턴스는 본래 동적 타입을 유지하고 "},{"type":"codeVoice","code":"as"},{"type":"text","text":", "},{"type":"codeVoice","code":"as?"},{"type":"text","text":", 또는 "},{"type":"codeVoice","code":"as!"},{"type":"text","text":" 와 같은 타입 캐스팅 연산자 (type-cast operators) 중 하나를 사용하여 타입을 캐스팅 할 수 있습니다. 예를 들어 "},{"type":"codeVoice","code":"as?"},{"type":"text","text":" 을 사용하여 배열의 첫번째 객체를 "},{"type":"codeVoice","code":"String"},{"type":"text","text":" 으로 조건부로 다운캐스트 합니다:"}]},{"type":"codeListing","syntax":"swift","code":["if let first = mixed.first as? String {","    print(\"The first item, '\\(first)', is a string.\")","}","\/\/ Prints \"The first item, 'one', is a string.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"캐스팅에 대한 자세한 내용은 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TypeCasting"},{"type":"text","text":" 을 참고 바랍니다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"AnyObject"},{"type":"text","text":" 프로토콜은 "},{"type":"codeVoice","code":"Any"},{"type":"text","text":" 타입과 유사합니다. 모든 클래스는 암시적으로 "},{"type":"codeVoice","code":"AnyObject"},{"type":"text","text":" 를 준수합니다. 언어에 의해 정의되는 "},{"type":"codeVoice","code":"Any"},{"type":"text","text":" 와 달리 "},{"type":"codeVoice","code":"AnyObject"},{"type":"text","text":" 는 Swift 표준 라이브러리에 의해 정의됩니다. 더 자세한 내용은 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Protocols#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%84%EC%9A%A9-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-Class-Only-Protocols"},{"type":"text","text":" 과 "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/anyobject"},{"type":"text","text":" 를 참고 바랍니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"any-type"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"Any"}]}]}],"type":"aside","name":"Grammar of an Any type"},{"anchor":"Self-타입-Self-Type","level":2,"type":"heading","text":"Self 타입 (Self Type)"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Self"},{"type":"text","text":" 타입은 특정 타입이 아니라 해당 타입의 이름을 반복하거나 알지 않아도 현재 타입을 편리하게 참조할 수 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"프로토콜 선언 또는 프로토콜 멤버 선언에서 "},{"type":"codeVoice","code":"Self"},{"type":"text","text":" 타입은 프로토콜을 준수하는 최종 타입을 나타냅니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"구조체, 클래스, 또는 열거형 선언에서 "},{"type":"codeVoice","code":"Self"},{"type":"text","text":" 타입은 선언에 의해 도입된 타입을 참조합니다. 타입의 멤버에 대한 선언 내에서 "},{"type":"codeVoice","code":"Self"},{"type":"text","text":" 타입은 해당 타입을 참조합니다. 클래스 선언의 멤버에서 "},{"type":"codeVoice","code":"Self"},{"type":"text","text":" 는 다음을 나타낼 수 있습니다:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"메서드의 반환 타입"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"읽기전용 서브 스크립트의 반환 타입"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"읽기전용 계산된 프로퍼티의 타입"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"메서드의 본문"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"예를 들어 아래의 코드는 반환 타입이 "},{"type":"codeVoice","code":"Self"},{"type":"text","text":" 인 인스턴스 메서드 "},{"type":"codeVoice","code":"f"},{"type":"text","text":" 를 보여줍니다."}]},{"type":"codeListing","syntax":"swift","code":["class Superclass {","    func f() -> Self { return self }","}","let x = Superclass()","print(type(of: x.f()))","\/\/ Prints \"Superclass\"","","class Subclass: Superclass { }","let y = Subclass()","print(type(of: y.f()))","\/\/ Prints \"Subclass\"","","let z: Superclass = Subclass()","print(type(of: z.f()))","\/\/ Prints \"Subclass\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"위의 예제의 마지막 부분은 "},{"type":"codeVoice","code":"Self"},{"type":"text","text":" 가 변수 자체의 컴파일 타임 타입 (compile-time type) "},{"type":"codeVoice","code":"Superclass"},{"type":"text","text":" 가 아닌 "},{"type":"codeVoice","code":"z"},{"type":"text","text":" 값의 런타임 타입 (runtime type) "},{"type":"codeVoice","code":"Subclass"},{"type":"text","text":" 를 참조하는 것을 보여줍니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"중첩된 타입 선언 내에서 "},{"type":"codeVoice","code":"Self"},{"type":"text","text":" 타입은 가장 안쪽 타입 선언에 의해 도입된 타입을 참조합니다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Self"},{"type":"text","text":" 타입은 Swift 표준 라이브러리에서 "},{"overridingTitleInlineContent":[{"type":"codeVoice","code":"type(of:)"}],"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/2885064-type","overridingTitle":"type(of:)"},{"type":"text","text":" 함수와 동일한 타입을 참조합니다. 현재 타입의 멤버를 접근하기 위해 "},{"type":"codeVoice","code":"Self.someStaticMember"},{"type":"text","text":" 라고 작성하는 것은 "},{"type":"codeVoice","code":"type(of:self).someStaticMember"},{"type":"text","text":" 로 작성하는 것과 동일합니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"self-type"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"Self"}]}]}],"type":"aside","name":"Grammar of a Self type"},{"anchor":"타입-상속-절-Type-Inheritance-Clause","level":2,"type":"heading","text":"타입 상속 절 (Type Inheritance Clause)"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"타입 상속 절 (type inheritance clause)"}]},{"type":"text","text":" 은 명명된 타입이 상속하는 클래스와 명명된 타입이 준수하는 프로토콜을 지정하기 위해 사용됩니다. 타입 상속 절은 콜론 ("},{"type":"codeVoice","code":":"},{"type":"text","text":") 으로 시작하고 그 뒤에 타입 식별자의 리스트가 옵니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"클래스 타입은 단일 상위 클래스를 상속할 수 있고 여러개의 프로토콜을 준수할 수 있습니다. 클래스를 정의할 때 상위 클래스의 이름은 타입 식별자의 리스트에서 첫번째로 나타나야 하고 다음으로 준수하는 여러개의 프로토콜이 옵니다. 클래스가 다른 클래스를 상속하지 않으면 리스트는 대신 프로토콜로 시작할 수 있습니다. 클래스 상속에 대한 자세한 설명과 예제는 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Inheritance"},{"type":"text","text":" 을 참고 바랍니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"다른 명명된 타입은 프로토콜의 리스트에서 상속하거나 준수할 수 있습니다. 프로토콜 타입은 여러 다른 프로토콜을 상속할 수 있습니다. 프로토콜 타입은 다른 프로토콜을 상속할 때 다른 프로토콜의 요구사항을 모으고 현재 프로토콜에서 상속되는 모든 타입은 모든 요구사항을 준수해야 합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"열거형 정의에 타입 상속 절은 프로토콜의 리스트이거나 케이스에 원시값 (raw values) 을 할당하는 열거형인 경우 해당 원시값의 타입을 지정하는 단일 명명된 타입일 수 있습니다. 타입 상속 절을 사용하여 원시값의 타입을 지정하는 열거형 정의의 예는 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Enumerations#%EC%9B%90%EC%8B%9C%EA%B0%92-Raw-Values"},{"type":"text","text":" 을 참고 바랍니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type-inheritance-clause"}]},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":":"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-inheritance-list"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type-inheritance-list"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"attributes"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-identifier"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"attributes"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-identifier"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":","}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-inheritance-list"}]}]}],"type":"aside","name":"Grammar of a type inheritance clause"},{"anchor":"타입-추론-Type-Inference","level":2,"type":"heading","text":"타입 추론 (Type Inference)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift 는 광범위하게 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"타입 추론 (type inference)"}]},{"type":"text","text":" 을 사용하므로 코드에서 많은 변수와 표현식의 타입 또는 타입의 부분을 생략할 수 있습니다. 예를 들어 "},{"type":"codeVoice","code":"var x: Int = 0"},{"type":"text","text":" 으로 작성하는 대신에 "},{"type":"codeVoice","code":"var x = 0"},{"type":"text","text":" 으로 타입을 완벽하게 생략하고 작성할 수 있습니다 — 컴파일러는 "},{"type":"codeVoice","code":"x"},{"type":"text","text":" 를 타입 "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 의 값으로 추론합니다. 유사하게 컨텍스트에서 전체 타입이 추론될 수 있을 때 타입의 부분을 생략할 수 있습니다. 예를 들어 "},{"type":"codeVoice","code":"let dict: Dictionary = [\"A\": 1]"},{"type":"text","text":" 을 작성하면 컴파일러는 "},{"type":"codeVoice","code":"dict"},{"type":"text","text":" 이 타입 "},{"type":"codeVoice","code":"Dictionary<String, Int>"},{"type":"text","text":" 이라고 추론합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"위의 두 예제에서 타입 정보는 표현식 트리의 잎에서 루트까지 전달됩니다. 즉, "},{"type":"codeVoice","code":"var x: Int = 0"},{"type":"text","text":" 에서 "},{"type":"codeVoice","code":"x"},{"type":"text","text":" 의 타입은 먼저 "},{"type":"codeVoice","code":"0"},{"type":"text","text":" 의 타입을 확인한 다음에 이 타입 정보를 루트 (변수 "},{"type":"codeVoice","code":"x"},{"type":"text","text":") 까지 전달하여 추론합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift 에서 타입 정보는 루트에서 잎까지 반대로 흐를 수도 있습니다. 예를 들어 다음 예제에서 상수 "},{"type":"codeVoice","code":"eFloat"},{"type":"text","text":" 에 명시적 타입 주석 ("},{"type":"codeVoice","code":": Float"},{"type":"text","text":") 은 숫자 리터럴 "},{"type":"codeVoice","code":"2.71828"},{"type":"text","text":" 이 "},{"type":"codeVoice","code":"Double"},{"type":"text","text":" 이 아닌 "},{"type":"codeVoice","code":"Float"},{"type":"text","text":" 타입을 유추하도록 합니다."}]},{"type":"codeListing","syntax":"swift","code":["let e = 2.71828 \/\/ The type of e is inferred to be Double.","let eFloat: Float = 2.71828 \/\/ The type of eFloat is Float."]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift 에서 타입 추론은 단일 표현식 또는 구문 수준에서 동작합니다. 이것은 표현식에서 생략된 타입 또는 타입의 일부를 추론하는데 필요한 모든 정보는 표현식 또는 하위 표현식 중 하나를 타입 검사 (type-checking) 하여 접근할 수 있습니다."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"identifier":{"url":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Types","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"내장된 타입과 복합 타입을 사용합니다."}],"kind":"article","metadata":{"title":"타입 (Types)"},"hierarchy":{"paths":[["doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean"]]},"references":{"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/CollectionTypes#%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC-Dictionaries":{"abstract":[],"title":"딕셔너리 (Dictionaries)","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/CollectionTypes#%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC-Dictionaries","url":"\/documentation\/the-swift-programming-language-korean\/collectiontypes#%25EB%2594%2595%25EC%2585%2594%25EB%2584%2588%25EB%25A6%25AC-Dictionaries"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Inheritance":{"role":"article","title":"상속 (Inheritance)","abstract":[{"type":"text","text":"기능을 추가 또는 재정의 하기 위한 하위 클래스 입니다."}],"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Inheritance","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language-korean\/inheritance"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Declarations#%ED%99%95%EC%9E%A5-%EC%84%A0%EC%96%B8-Extension-Declaration":{"abstract":[],"title":"확장 선언 (Extension Declaration)","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%ED%99%95%EC%9E%A5-%EC%84%A0%EC%96%B8-Extension-Declaration","url":"\/documentation\/the-swift-programming-language-korean\/declarations#%25ED%2599%2595%25EC%259E%25A5-%25EC%2584%25A0%25EC%2596%25B8-Extension-Declaration"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Functions#In-Out-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-In-Out-Parameters":{"abstract":[],"title":"In-Out 파라미터 (In-Out Parameters)","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions#In-Out-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-In-Out-Parameters","url":"\/documentation\/the-swift-programming-language-korean\/functions#In-Out-%25ED%258C%258C%25EB%259D%25BC%25EB%25AF%25B8%25ED%2584%25B0-In-Out-Parameters"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/TheBasics#%EC%95%94%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%96%B8%EB%9E%98%ED%95%91%EB%90%9C-%EC%98%B5%EC%85%94%EB%84%90-Implicitly-Unwrapped-Optionals":{"abstract":[],"title":"암시적으로 언래핑된 옵셔널 (Implicitly Unwrapped Optionals)","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TheBasics#%EC%95%94%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%96%B8%EB%9E%98%ED%95%91%EB%90%9C-%EC%98%B5%EC%85%94%EB%84%90-Implicitly-Unwrapped-Optionals","url":"\/documentation\/the-swift-programming-language-korean\/thebasics#%25EC%2595%2594%25EC%258B%259C%25EC%25A0%2581%25EC%259C%25BC%25EB%25A1%259C-%25EC%2596%25B8%25EB%259E%2598%25ED%2595%2591%25EB%2590%259C-%25EC%2598%25B5%25EC%2585%2594%25EB%2584%2590-Implicitly-Unwrapped-Optionals"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Functions#%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-%EB%B0%98%ED%99%98%EA%B0%92%EC%9D%B4-%EC%9E%88%EB%8A%94-%ED%95%A8%EC%88%98-Functions-with-Multiple-Return-Values":{"abstract":[],"title":"여러개의 반환값이 있는 함수 (Functions with Multiple Return Values)","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions#%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-%EB%B0%98%ED%99%98%EA%B0%92%EC%9D%B4-%EC%9E%88%EB%8A%94-%ED%95%A8%EC%88%98-Functions-with-Multiple-Return-Values","url":"\/documentation\/the-swift-programming-language-korean\/functions#%25EC%2597%25AC%25EB%259F%25AC%25EA%25B0%259C%25EC%259D%2598-%25EB%25B0%2598%25ED%2599%2598%25EA%25B0%2592%25EC%259D%25B4-%25EC%259E%2588%25EB%258A%2594-%25ED%2595%25A8%25EC%2588%2598-Functions-with-Multiple-Return-Values"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean":{"role":"collection","title":"The Swift Programming Language (한국어)","abstract":[],"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language-korean"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Enumerations#%EC%9B%90%EC%8B%9C%EA%B0%92-Raw-Values":{"abstract":[],"title":"원시값 (Raw Values)","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Enumerations#%EC%9B%90%EC%8B%9C%EA%B0%92-Raw-Values","url":"\/documentation\/the-swift-programming-language-korean\/enumerations#%25EC%259B%2590%25EC%258B%259C%25EA%25B0%2592-Raw-Values"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Closures#%EC%9E%90%EB%8F%99-%ED%81%B4%EB%A1%9C%EC%A0%80-Autoclosures":{"abstract":[],"title":"자동 클로저 (Autoclosures)","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Closures#%EC%9E%90%EB%8F%99-%ED%81%B4%EB%A1%9C%EC%A0%80-Autoclosures","url":"\/documentation\/the-swift-programming-language-korean\/closures#%25EC%259E%2590%25EB%258F%2599-%25ED%2581%25B4%25EB%25A1%259C%25EC%25A0%2580-Autoclosures"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Extensions":{"role":"article","title":"확장 (Extensions)","abstract":[{"type":"text","text":"기존 타입에 기능을 추가합니다."}],"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Extensions","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language-korean\/extensions"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/TheBasics#%EC%98%B5%EC%85%94%EB%84%90-Optionals":{"abstract":[],"title":"옵셔널 (Optionals)","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TheBasics#%EC%98%B5%EC%85%94%EB%84%90-Optionals","url":"\/documentation\/the-swift-programming-language-korean\/thebasics#%25EC%2598%25B5%25EC%2585%2594%25EB%2584%2590-Optionals"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Declarations#%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-%EB%8D%98%EC%A7%80%EA%B8%B0-Throwing-Functions-and-Methods":{"abstract":[],"title":"함수와 메서드 던지기 (Throwing Functions and Methods)","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-%EB%8D%98%EC%A7%80%EA%B8%B0-Throwing-Functions-and-Methods","url":"\/documentation\/the-swift-programming-language-korean\/declarations#%25ED%2595%25A8%25EC%2588%2598%25EC%2599%2580-%25EB%25A9%2594%25EC%2584%259C%25EB%2593%259C-%25EB%258D%2598%25EC%25A7%2580%25EA%25B8%25B0-Throwing-Functions-and-Methods"},"https://developer.apple.com/documentation/swift/2885064-type":{"title":"type(of:)","titleInlineContent":[{"type":"codeVoice","code":"type(of:)"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/2885064-type","url":"https:\/\/developer.apple.com\/documentation\/swift\/2885064-type"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Declarations#%EB%8B%A4%EC%8B%9C-%EB%8D%98%EC%A7%80%EB%8A%94-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-Rethrowing-Functions-and-Methods":{"abstract":[],"title":"다시 던지는 함수와 메서드 (Rethrowing Functions and Methods)","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%EB%8B%A4%EC%8B%9C-%EB%8D%98%EC%A7%80%EB%8A%94-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-Rethrowing-Functions-and-Methods","url":"\/documentation\/the-swift-programming-language-korean\/declarations#%25EB%258B%25A4%25EC%258B%259C-%25EB%258D%2598%25EC%25A7%2580%25EB%258A%2594-%25ED%2595%25A8%25EC%2588%2598%25EC%2599%2580-%25EB%25A9%2594%25EC%2584%259C%25EB%2593%259C-Rethrowing-Functions-and-Methods"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Protocols#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%84%EC%9A%A9-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-Class-Only-Protocols":{"abstract":[],"title":"클래스 전용 프로토콜 (Class-Only Protocols)","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Protocols#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%84%EC%9A%A9-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-Class-Only-Protocols","url":"\/documentation\/the-swift-programming-language-korean\/protocols#%25ED%2581%25B4%25EB%259E%2598%25EC%258A%25A4-%25EC%25A0%2584%25EC%259A%25A9-%25ED%2594%2584%25EB%25A1%259C%25ED%2586%25A0%25EC%25BD%259C-Class-Only-Protocols"},"https://developer.apple.com/documentation/swift/anyobject":{"title":"AnyObject","titleInlineContent":[{"type":"codeVoice","code":"AnyObject"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/anyobject","url":"https:\/\/developer.apple.com\/documentation\/swift\/anyobject"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/MemorySafety":{"role":"article","title":"메모리 안전성 (Memory Safety)","abstract":[{"type":"text","text":"메모리 접근할 때 충돌을 피하기위해 코드를 구조화합니다."}],"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/MemorySafety","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language-korean\/memorysafety"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/CollectionTypes#%EB%B0%B0%EC%97%B4-Arrays":{"abstract":[],"title":"배열 (Arrays)","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/CollectionTypes#%EB%B0%B0%EC%97%B4-Arrays","url":"\/documentation\/the-swift-programming-language-korean\/collectiontypes#%25EB%25B0%25B0%25EC%2597%25B4-Arrays"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Functions#%EA%B0%80%EB%B3%80-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-Variadic-Parameters":{"abstract":[],"title":"가변 파라미터 (Variadic Parameters)","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions#%EA%B0%80%EB%B3%80-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-Variadic-Parameters","url":"\/documentation\/the-swift-programming-language-korean\/functions#%25EA%25B0%2580%25EB%25B3%2580-%25ED%258C%258C%25EB%259D%25BC%25EB%25AF%25B8%25ED%2584%25B0-Variadic-Parameters"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/TypeCasting":{"role":"article","title":"타입 캐스팅 (Type Casting)","abstract":[{"type":"text","text":"값의 런타임 타입을 정하고 타입의 정보를 제공합니다."}],"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/TypeCasting","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language-korean\/typecasting"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Declarations#%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-Asynchronous-Functions-and-Methods":{"abstract":[],"title":"비동기 함수와 메서드 (Asynchronous Functions and Methods)","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Declarations#%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%95%A8%EC%88%98%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C-Asynchronous-Functions-and-Methods","url":"\/documentation\/the-swift-programming-language-korean\/declarations#%25EB%25B9%2584%25EB%258F%2599%25EA%25B8%25B0-%25ED%2595%25A8%25EC%2588%2598%25EC%2599%2580-%25EB%25A9%2594%25EC%2584%259C%25EB%2593%259C-Asynchronous-Functions-and-Methods"}}}