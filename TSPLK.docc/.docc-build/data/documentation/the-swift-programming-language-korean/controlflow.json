{"primaryContentSections":[{"kind":"content","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift는 다양한 제어 흐름 (control flow) 구문을 제공합니다. 이것은 여러번 작업을 수행하는 "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프를 포함하고 조건에 따라 다르게 실행되는 "},{"type":"codeVoice","code":"if"},{"type":"text","text":", "},{"type":"codeVoice","code":"guard"},{"type":"text","text":", "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문과 코드에서 다른 포인트로 실행 플로우를 전달하는 "},{"type":"codeVoice","code":"break"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" 를 포함합니다. Swift는 배열, 딕셔너리, 범위, 문자열, 그리고 다른 연속적인 것에 대한 반복을 쉽게 만들어 주는 "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" 루프를 제공합니다. Swift는 또한 현재 범위를 벗어날 때 수행되는 코드인 "},{"type":"codeVoice","code":"defer"},{"type":"text","text":" 구문을 제공합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift의 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문은 C와 같은 언어들의 구문보다 훨씬 더 강력합니다. 케이스들은 간격 매치, 튜플, 그리고 특정 타입으로의 캐스트를 포함하여 다른 많은 패턴을 비교할 수 있습니다. "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 케이스에서 매치된 값은 케이스 문 안에서 사용할 수 있는 임시의 상수 또는 변수로 사용이 가능하고 복잡한 매칭 조건은 각 케이스에 대해 "},{"type":"codeVoice","code":"where"},{"type":"text","text":" 절로 표현될 수 있습니다."}]},{"anchor":"For-In-루프-For-In-Loops","level":2,"type":"heading","text":"For-In 루프 (For-In Loops)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"배열에 아이템, 범위의 숫자, 또는 문자열에 문자와 같은 연속된 것에 대해 "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" 루프를 사용하여 반복할 수 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 예제는 "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" 루프를 사용하여 배열의 아이템을 반복합니다:"}]},{"type":"codeListing","syntax":"swift","code":["let names = [\"Anna\", \"Alex\", \"Brian\", \"Jack\"]","for name in names {","    print(\"Hello, \\(name)!\")","}","\/\/ Hello, Anna!","\/\/ Hello, Alex!","\/\/ Hello, Brian!","\/\/ Hello, Jack!"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"딕셔너리의 키-값 쌍 접근을 위해 반복을 사용할 수도 있습니다. 딕셔너리의 각 아이템은 딕셔너리가 반복될 때 "},{"type":"codeVoice","code":"(key, value)"},{"type":"text","text":" 튜플로 반환되고 "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" 루프 본문 내에서 사용하기 위해 "},{"type":"codeVoice","code":"(key, value)"},{"type":"text","text":" 튜플의 멤버를 명시적으로 이름을 가진 상수로 분해할 수 있습니다. 아래의 예제에서 딕셔너리의 키는 "},{"type":"codeVoice","code":"animalName"},{"type":"text","text":" 상수로 분해되고 딕셔너리의 값은 "},{"type":"codeVoice","code":"legCount"},{"type":"text","text":" 상수로 분해됩니다."}]},{"type":"codeListing","syntax":"swift","code":["let numberOfLegs = [\"spider\": 8, \"ant\": 6, \"cat\": 4]","for (animalName, legCount) in numberOfLegs {","    print(\"\\(animalName)s have \\(legCount) legs\")","}","\/\/ cats have 4 legs","\/\/ ants have 6 legs","\/\/ spiders have 8 legs"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" 의 콘텐츠는 기본적으로 순서가 없으며 반복으로 가져올 아이템에 대한 순서를 보장하지 않습니다. 특히 아이템을 딕셔너리에 삽입하는 순서는 아이템이 반복되는 순서를 정의하지 않습니다. 배열과 딕셔너리의 자세한 내용은 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/CollectionTypes"},{"type":"text","text":" 을 참고 바랍니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"숫자 범위에 대해 "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" 루프를 사용할 수도 있습니다. 이 예제는 5의 배수 항목을 몇개 출력합니다:"}]},{"type":"codeListing","syntax":"swift","code":["for index in 1...5 {","    print(\"\\(index) times 5 is \\(index * 5)\")","}","\/\/ 1 times 5 is 5","\/\/ 2 times 5 is 10","\/\/ 3 times 5 is 15","\/\/ 4 times 5 is 20","\/\/ 5 times 5 is 25"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 반복되는 시퀀스는 닫힌 범위 연산자 ("},{"type":"codeVoice","code":"..."},{"type":"text","text":")를 사용하여 표시되는 "},{"type":"codeVoice","code":"1"},{"type":"text","text":" 부터 "},{"type":"codeVoice","code":"5"},{"type":"text","text":" 까지의 숫자 범위 입니다. "},{"type":"codeVoice","code":"index"},{"type":"text","text":" 의 값은 범위의 첫번째 숫자 ("},{"type":"codeVoice","code":"1"},{"type":"text","text":")로 설정되고 루프 안의 구문이 실행됩니다. 이 경우 루프는 "},{"type":"codeVoice","code":"index"},{"type":"text","text":" 의 현재 값을 5배 하여 출력하는 하나의 구문만 포함합니다. 구문이 실행된 후에 "},{"type":"codeVoice","code":"index"},{"type":"text","text":" 의 값은 범위의 두번째 값 ("},{"type":"codeVoice","code":"2"},{"type":"text","text":")로 업데이트 되고 "},{"type":"codeVoice","code":"print(_:separator:terminator:)"},{"type":"text","text":" 함수가 다시 호출됩니다. 이 프로세스는 범위의 끝에 도달할 때까지 계속 됩니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"위의 예제에서 "},{"type":"codeVoice","code":"index"},{"type":"text","text":" 는 루프의 각 반복이 시작할 때 자동으로 설정되는 값인 상수입니다. 따라서 "},{"type":"codeVoice","code":"index"},{"type":"text","text":" 를 사용하기 전에 선언할 필요가 없습니다. "},{"type":"codeVoice","code":"let"},{"type":"text","text":" 선언 키워드가 필요없이 루프 선언에 포함되어 암시적으로 선언됩니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"시퀀스로 부터 각 값이 필요하지 않으면 변수 이름의 위치에 언더바를 사용하여 값을 무시할 수 있습니다."}]},{"type":"codeListing","syntax":"swift","code":["let base = 3","let power = 10","var answer = 1","for _ in 1...power {","    answer *= base","}","print(\"\\(base) to the power of \\(power) is \\(answer)\")","\/\/ Prints \"3 to the power of 10 is 59049\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"위의 예는 한 숫자의 값을 다른 숫자의 제곱으로 계산합니다 (이 경우 "},{"type":"codeVoice","code":"3"},{"type":"text","text":" 에서 "},{"type":"codeVoice","code":"10"},{"type":"text","text":" 제곱). "},{"type":"codeVoice","code":"1"},{"type":"text","text":" 로 시작하고 "},{"type":"codeVoice","code":"10"},{"type":"text","text":" 으로 끝나는 닫힌 범위를 사용하여 시작값 "},{"type":"codeVoice","code":"1"},{"type":"text","text":" (즉, "},{"type":"codeVoice","code":"3"},{"type":"text","text":" 의 "},{"type":"codeVoice","code":"0"},{"type":"text","text":" 제곱)에 "},{"type":"codeVoice","code":"3"},{"type":"text","text":" 을 "},{"type":"codeVoice","code":"10"},{"type":"text","text":" 번 곱합니다. 이 계산에서 루프의 각 카운터 값은 불필요 합니다. 즉 이 코드는 간단하게 올바른 숫자만큼 실행됩니다. 루프 변수 위치에 사용된 언더바 문자 ("},{"type":"codeVoice","code":"_"},{"type":"text","text":")는 각 값을 무시하고 루프의 각 반복동안 현재 값에 접근하는 것을 제공하지 않습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"어떤 상황에선 양 끝점을 포함하는 닫힌 범위를 사용하지 않을 수 있습니다. 시계 페이스에 매 분마다 눈금을 그리는 것을 생각해 봅시다. "},{"type":"codeVoice","code":"0"},{"type":"text","text":" 분을 시작으로 "},{"type":"codeVoice","code":"60"},{"type":"text","text":" 개의 눈금을 그려야 합니다. 이럴 경우 반열림 범위 연산자 ("},{"type":"codeVoice","code":"..<"},{"type":"text","text":")를 사용하여 가장 최소 값은 포함하지만 최대 값은 포함되지 않게 사용할 수 있습니다. 범위에 대한 자세한 내용은 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/BasicOperators#%EB%B2%94%EC%9C%84-%EC%97%B0%EC%82%B0%EC%9E%90-Range-Operators"},{"type":"text","text":" 를 참고 바랍니다."}]},{"type":"codeListing","syntax":"swift","code":["let minutes = 60","for tickMark in 0..<minutes {","    \/\/ render the tick mark each minute (60 times)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"어떤 사용자는 UI에 더 적은 눈금을 원할 수도 있습니다. 매 5분마다 눈금을 그리기 원할 수 있습니다. 원하지 않는 눈금을 건너뛰기 위해 "},{"type":"codeVoice","code":"stride(from:to:by:)"},{"type":"text","text":" 함수를 사용 하십시오."}]},{"type":"codeListing","syntax":"swift","code":["let minuteInterval = 5","for tickMark in stride(from: 0, to: minutes, by: minuteInterval) {","    \/\/ render the tick mark every 5 minutes (0, 5, 10, 15 ... 45, 50, 55)","}"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"stride(from:through:by:)"},{"type":"text","text":" 사용하여 닫힌 범위도 가능합니다:"}]},{"type":"codeListing","syntax":"swift","code":["let hours = 12","let hourInterval = 3","for tickMark in stride(from: 3, through: hours, by: hourInterval) {","    \/\/ render the tick mark every 3 hours (3, 6, 9, 12)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"위의 예제는 범위, 배열, 딕셔너리, 그리고 문자열을 조회하기 위해 "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" 루프를 사용합니다. 자체 클래스와 콜렉션 타입을 포함하여 모든 콜렉션을 조회하기 위해 "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/sequence"},{"type":"text","text":" 프로토콜을 준수하는 한 이 구문을 사용할 수 있습니다."}]},{"anchor":"While-루프-While-Loops","level":2,"type":"heading","text":"While 루프 (While Loops)"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프는 조건이 "},{"type":"codeVoice","code":"false"},{"type":"text","text":" 가 될 때까지 구문을 수행합니다. 이러한 루프는 첫번째 반복이 시작되기 전에 반복 횟수를 알 수 없을 때 가장 잘 사용됩니다. Swift는 두 종류의 "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프를 제공합니다:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"while"},{"type":"text","text":" 은 루프가 시작할 때마다 조건을 비교합니다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"repeat"},{"type":"text","text":"-"},{"type":"codeVoice","code":"while"},{"type":"text","text":" 은 루프가 끝날 때 마다 조건을 비교합니다."}]}]}]},{"anchor":"While","level":3,"type":"heading","text":"While"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프는 단일 조건의 평가로 시작합니다. 조건이 "},{"type":"codeVoice","code":"true"},{"type":"text","text":" 이면 조건이 "},{"type":"codeVoice","code":"false"},{"type":"text","text":" 가 될 때까지 구문은 반복 됩니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"여기 "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프의 기본 형식 입니다:"}]},{"type":"codeListing","syntax":"swift","code":["while <#condition#> {","   <#statements#>","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 예제는 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Snakes and Ladders"}]},{"type":"text","text":" (또는 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Chutes and Ladders"}]},{"type":"text","text":") 게임을 플레이 합니다:"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"snakesAndLadders"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"게임의 규칙은 아래와 같습니다:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"이 보드는 25개의 정사각형을 가지고 있고 25에 착륙 또는 25를 넘는 것이 목표입니다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"플레이어의 시작 정사각형을 보드의 좌측 하단의 모서리로 “정사각형 0” 이라 합니다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"각 턴마다 주사위를 굴리고 위의 점선 화살표 방향으로 각 숫자만큼 정사각형을 이동합니다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"턴이 사다리의 바닥에서 끝나면 사다리를 타고 올라갑니다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"턴이 뱀의 머리에서 끝나면 뱀의 꼬리로 내려갑니다."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"게임 보드는 "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 값의 배열로 표현됩니다. 크기는 "},{"type":"codeVoice","code":"finalSquare"},{"type":"text","text":" 라는 상수를 기반으로 하며 배열을 초기화하고 나중에 예제에서 승리 조건을 확인하는데 사용됩니다. “정사각형 0”에서 플레이어는 시작하기 때문에 보드는 0 "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" 값을 포함하여 25가 아닌 26의 크기로 초기화 됩니다."}]},{"type":"codeListing","syntax":"swift","code":["let finalSquare = 25","var board = [Int](repeating: 0, count: finalSquare + 1)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"그런 다음 일부 사각형은 뱀과 사다리에 대해 더 구체적인 값을 갖도록 설정됩니다. 사다리 기반의 정사각형은 보드의 위로 이동하기 때문에 양수를 가지는 반면에 뱀 머리의 정사각형은 보드의 아래로 이동하기 때문에 음수를 가집니다."}]},{"type":"codeListing","syntax":"swift","code":["board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02","board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"정사각형 3은 정사각형 11로 이동하는 사다리 바닥이 포함됩니다. 이것을 표현하기 위해 "},{"type":"codeVoice","code":"board[03]"},{"type":"text","text":" 은 정수값 "},{"type":"codeVoice","code":"8"},{"type":"text","text":" ("},{"type":"codeVoice","code":"3"},{"type":"text","text":" 과 "},{"type":"codeVoice","code":"11"},{"type":"text","text":" 의 차이)과 동등한 "},{"type":"codeVoice","code":"+08"},{"type":"text","text":" 을 대입합니다. 값과 구문을 정렬하기 위해 단항 덧셈 연산자 ("},{"type":"codeVoice","code":"+i"},{"type":"text","text":")는 단항 빼기 연산자 ("},{"type":"codeVoice","code":"-i"},{"type":"text","text":")를 명시적으로 사용하고 10보다 작은 숫자의 앞에 0을 채웁니다 (두 스타일 모두 꼭 필요한 것은 아니지만 코드가 깔끔해 집니다)."}]},{"type":"codeListing","syntax":"swift","code":["var square = 0","var diceRoll = 0","while square < finalSquare {","    \/\/ roll the dice","    diceRoll += 1","    if diceRoll == 7 { diceRoll = 1 }","    \/\/ move by the rolled amount","    square += diceRoll","    if square < board.count {","        \/\/ if we're still on the board, move up or down for a snake or a ladder","        square += board[square]","    }","}","print(\"Game over!\")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"위의 예는 주사위 굴리기에 매우 간단한 접근 방식을 사용합니다. 난수를 생성하는 대신에 "},{"type":"codeVoice","code":"diceRoll"},{"type":"text","text":" 은 "},{"type":"codeVoice","code":"0"},{"type":"text","text":" 의 값으로 시작합니다. 매 "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프를 실행할 때 마다 "},{"type":"codeVoice","code":"diceRoll"},{"type":"text","text":" 은 1씩 증가하고 너무 커졌는지 확인합니다. 반환된 값이 "},{"type":"codeVoice","code":"7"},{"type":"text","text":" 과 같을 때마다 주사위 굴림이 너무 커지므로 값을 "},{"type":"codeVoice","code":"1"},{"type":"text","text":" 로 재설정 합니다. 그 결과 "},{"type":"codeVoice","code":"diceRoll"},{"type":"text","text":" 값은 항상 "},{"type":"codeVoice","code":"1"},{"type":"text","text":", "},{"type":"codeVoice","code":"2"},{"type":"text","text":", "},{"type":"codeVoice","code":"3"},{"type":"text","text":", "},{"type":"codeVoice","code":"4"},{"type":"text","text":", "},{"type":"codeVoice","code":"5"},{"type":"text","text":", "},{"type":"codeVoice","code":"6"},{"type":"text","text":", "},{"type":"codeVoice","code":"1"},{"type":"text","text":", "},{"type":"codeVoice","code":"2"},{"type":"text","text":" 등과 같이 시퀀스 입니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"주사위를 굴리고 난 후에 플레이어는 "},{"type":"codeVoice","code":"diceRoll"},{"type":"text","text":" 정사각형으로 앞으로 이동합니다. 주사위 굴림이 플레이어를 정사각형 25를 넘어 이동할 수 있으며 이럴 경우 게임이 끝납니다. 이 시나리오에 대처하기 위해 "},{"type":"codeVoice","code":"board"},{"type":"text","text":" 배열의 "},{"type":"codeVoice","code":"count"},{"type":"text","text":" 프로퍼티가 "},{"type":"codeVoice","code":"square"},{"type":"text","text":" 보다 작은지 확인합니다. "},{"type":"codeVoice","code":"square"},{"type":"text","text":" 가 유효하다면 "},{"type":"codeVoice","code":"board[square]"},{"type":"text","text":" 에 저장된 값은 현재 "},{"type":"codeVoice","code":"square"},{"type":"text","text":" 값이 추가되어 플레이어를 이동합니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Note"},{"type":"text","text":" "},{"type":"text","text":"확인을 수행하지 않으면 "},{"type":"codeVoice","code":"board[square]"},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"board"},{"type":"text","text":" 배열의 범위를 넘는 값을 접근하려 시도할 수 있습니다. 이런 경우 런타임 에러가 발생합니다."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"현재 "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프의 실행이 끝나면 루프를 다시 실행해야 되는지 알기위해 조건을 확인합니다. 플레이어가 정사각형 숫자 "},{"type":"codeVoice","code":"25"},{"type":"text","text":" 에 위치하거나 넘으면 루프 조건은 "},{"type":"codeVoice","code":"false"},{"type":"text","text":" 가 되고 게임은 종료됩니다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프가 시작될 때 게임의 길이가 명확하지 않으므로 이러한 경우 "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프가 적절합니다. 대신에 루프는 특정 조건이 만족할 때까지 실행됩니다."}]},{"anchor":"Repeat-While","level":3,"type":"heading","text":"Repeat-While"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프의 다른 하나는 루프의 조건을 판단하기 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"전에"}]},{"type":"text","text":" 루프 블럭을 처음에 한번 먼저 통과하는 "},{"type":"codeVoice","code":"repeat"},{"type":"text","text":"-"},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프가 있습니다. 조건이 "},{"type":"codeVoice","code":"false"},{"type":"text","text":" 가 될 때까지 루프를 반복합니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Note"},{"type":"text","text":" "},{"type":"text","text":"Swift에 "},{"type":"codeVoice","code":"repeat"},{"type":"text","text":"-"},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프는 다른 언어의 "},{"type":"codeVoice","code":"do"},{"type":"text","text":"-"},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프와 유사합니다."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"여기 "},{"type":"codeVoice","code":"repeat"},{"type":"text","text":"-"},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프의 일반적인 형식입니다:"}]},{"type":"codeListing","syntax":"swift","code":["repeat {","   <#statements#>","} while <#condition#>"]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Snakes and Ladders"}]},{"type":"text","text":" 예제에서 "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프보다 "},{"type":"codeVoice","code":"repeat"},{"type":"text","text":"-"},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프를 쓰는 것이 더 좋습니다. "},{"type":"codeVoice","code":"finalSquare"},{"type":"text","text":", "},{"type":"codeVoice","code":"board"},{"type":"text","text":", "},{"type":"codeVoice","code":"square"},{"type":"text","text":", "},{"type":"codeVoice","code":"diceRoll"},{"type":"text","text":" 의 값은 "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프에서와 같은 방식으로 초기화 됩니다."}]},{"type":"codeListing","syntax":"swift","code":["let finalSquare = 25","var board = [Int](repeating: 0, count: finalSquare + 1)","board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02","board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08","var square = 0","var diceRoll = 0"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 게임의 버전에서는 루프에서 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"첫번째"}]},{"type":"text","text":" 행동은 사다리 또는 뱀인지 확인합니다. 보드에 사다리가 없으면 플레이어는 바로 정사각형 25로 이동하게 되고 사다리를 위로 이동하여 게임에서 이길 수 없습니다. 따라서 루프의 첫번째 동작으로 뱀 또는 사다리를 확인하는 것이 안전합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"게임 시작할 때 플레이어는 “정사각형 0”에 있습니다. "},{"type":"codeVoice","code":"board[0]"},{"type":"text","text":" 은 항상 "},{"type":"codeVoice","code":"0"},{"type":"text","text":" 과 같으며 영향이 없습니다."}]},{"type":"codeListing","syntax":"swift","code":["repeat {","    \/\/ move up or down for a snake or ladder","    square += board[square]","    \/\/ roll the dice","    diceRoll += 1","    if diceRoll == 7 { diceRoll = 1 }","    \/\/ move by the rolled amount","    square += diceRoll","} while square < finalSquare","print(\"Game over!\")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"뱀과 사다리를 코드는 확인 후에 주사위를 굴리고 플레이어를 "},{"type":"codeVoice","code":"diceRoll"},{"type":"text","text":" 정사각형에 따라 앞으로 이동합니다. 그러면 현재 루프는 종료됩니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"루프의 조건 ("},{"type":"codeVoice","code":"while square < finalSquare"},{"type":"text","text":")은 이전과 같지만 루프를 통과하는 첫번째 실행의 끝까지는 동일하지 않습니다. 이전 예제의 "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프보다 이 게임에서는 "},{"type":"codeVoice","code":"repeat"},{"type":"text","text":"-"},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프가 더 적합합니다. 위의 "},{"type":"codeVoice","code":"repeat"},{"type":"text","text":"-"},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프에서 "},{"type":"codeVoice","code":"square += board[square]"},{"type":"text","text":" 는 루프의 "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 조건이 "},{"type":"codeVoice","code":"square"},{"type":"text","text":" 가 항상 보드 위에 있는 것을 확인 한 직후에 실행 됩니다. 이 동작은 이전 예제에서 "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프 버전에서 배열의 범위를 체크할 필요가 없습니다."}]},{"anchor":"조건-구문-Conditional-Statements","level":2,"type":"heading","text":"조건 구문 (Conditional Statements)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"조건이 포함하는 코드 기반의 다른 조각을 실행할 때 유용한 경우가 있습니다. 에러가 발생하거나 값이 너무 크거나 작을 때 메세지를 출력하려고 할 때 코드의 별도의 부분을 실행하고 싶을 수 있습니다. 이러한 동작을 위해 코드 조건부의 부분을 만들어야 합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift는 코드에 조건부를 추가하는 방법은 "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 구문과 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문으로 2가지 제공합니다. 일반적으로 "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 구문은 가능한 결과가 적은 간단한 조건에 적합합니다. "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문은 가능한 결과가 여러개이며 더 복잡한 조건에 적합하고 실행해야 할 적절한 코드 분기를 선택해야 하는 패턴 매칭 상태에 유용합니다."}]},{"anchor":"If","level":3,"type":"heading","text":"If"},{"type":"paragraph","inlineContent":[{"type":"text","text":"가장 간단한 형식으로 "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 구문은 단일 "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 조건을 갖습니다. 조건이 "},{"type":"codeVoice","code":"true"},{"type":"text","text":" 일 경우에만 구문을 실행합니다."}]},{"type":"codeListing","syntax":"swift","code":["var temperatureInFahrenheit = 30","if temperatureInFahrenheit <= 32 {","    print(\"It's very cold. Consider wearing a scarf.\")","}","\/\/ Prints \"It's very cold. Consider wearing a scarf.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"위 예제는 기온이 화씨 32도 보다 작거나 같은지 확인합니다. 만약 화씨 32도 보다 작거나 같으면 메세지가 출력됩니다. 반대는 메세지가 출력되지 않으며 코드는 "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 구문의 닫힘 중괄호 이후를 계속 실행합니다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"if"},{"type":"text","text":" 구문은 "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 조건이 "},{"type":"codeVoice","code":"false"},{"type":"text","text":" 일 때 그밖의 다른 구문을 제공할 수 있습니다. 이 구문은 "},{"type":"codeVoice","code":"else"},{"type":"text","text":" 키워드로 표기합니다."}]},{"type":"codeListing","syntax":"swift","code":["temperatureInFahrenheit = 40","if temperatureInFahrenheit <= 32 {","    print(\"It's very cold. Consider wearing a scarf.\")","} else {","    print(\"It's not that cold. Wear a t-shirt.\")","}","\/\/ Prints \"It's not that cold. Wear a t-shirt.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"2개의 중괄호 중 하나는 항상 실행됩니다. 기온이 증가하여 화씨 "},{"type":"codeVoice","code":"40"},{"type":"text","text":" 도를 가지므로 더이상 추워서 스카프를 해야 한다고 충고하지 않으며 "},{"type":"codeVoice","code":"else"},{"type":"text","text":" 구문이 실행 됩니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"추가 절을 고려하기 위해 여러 "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 구문을 연결할 수 있습니다."}]},{"type":"codeListing","syntax":"swift","code":["temperatureInFahrenheit = 90","if temperatureInFahrenheit <= 32 {","    print(\"It's very cold. Consider wearing a scarf.\")","} else if temperatureInFahrenheit >= 86 {","    print(\"It's really warm. Don't forget to wear sunscreen.\")","} else {","    print(\"It's not that cold. Wear a t-shirt.\")","}","\/\/ Prints \"It's really warm. Don't forget to wear sunscreen.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"여기 "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 구문은 특정 따뜻한 기온에 응답하기 위해 추가 되었습니다. 마지막 "},{"type":"codeVoice","code":"else"},{"type":"text","text":" 절은 남아있고 어떤 기온이 너무 따뜻하거나 너무 춥지 않을 경우에 응답을 출력합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"그러나 마지막 "},{"type":"codeVoice","code":"else"},{"type":"text","text":" 절은 옵셔널이고 이 조건이 완벽하게 필요가 없으면 제외할 수 있습니다."}]},{"type":"codeListing","syntax":"swift","code":["temperatureInFahrenheit = 72","if temperatureInFahrenheit <= 32 {","    print(\"It's very cold. Consider wearing a scarf.\")","} else if temperatureInFahrenheit >= 86 {","    print(\"It's really warm. Don't forget to wear sunscreen.\")","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"기온이 너무 춥지도 따뜻하지도 않아 "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"else if"},{"type":"text","text":" 조건에 포함되지 않으므로 아무런 메세지가 출력되지 않습니다."}]},{"anchor":"Switch","level":3,"type":"heading","text":"Switch"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문은 값을 고려하고 가능한 여러개의 일치 패턴과 비교합니다. 그런 다음 첫번째로 일치하는 패턴을 기반으로 적절한 코드 블럭을 실행합니다. "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문은 여러 가능한 상태에 응답하기 위해 "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 구문의 대체 구문으로 제공합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"가장 간단한 형식으로 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문은 하나 이상의 같은 타입의 값과 비교합니다."}]},{"type":"codeListing","syntax":"swift","code":["switch <#some value to consider#> {","case <#value 1#>:","    <#respond to value 1#>","case <#value 2#>,","    <#value 3#>:","    <#respond to value 2 or 3#>","default:","    <#otherwise, do something else#>","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"모든 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문은 각각 "},{"type":"codeVoice","code":"case"},{"type":"text","text":" 키워드로 시작하는 여러개의 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"케이스"}]},{"type":"text","text":" 로 구성되어 있습니다. 특정 값과 비교하는 것 외에도 Swift는 각 케이스에 대해 더 복잡한 일치 패턴을 지정하는 여러가지 방법을 제공합니다. 이 옵션은 이 챕터 뒤에서 다루겠습니다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"if"},{"type":"text","text":" 구문의 본문과 같이 각 "},{"type":"codeVoice","code":"case"},{"type":"text","text":" 는 코드 실행 부분이 분리되어 있습니다. "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문은 실행 될 부분을 선택합니다. 이 절차를 값의 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"스위칭 (switching)"}]},{"type":"text","text":" 이라 알려져 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"모든 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문은 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"완벽"}]},{"type":"text","text":" 해야 합니다. 이것은 고려중인 타입의 가능한 모든 값은 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 케이스 중 하나와 일치해야 합니다. 가능한 모든 값에 대한 케이스를 제공하는 것이 적절하지 않은 경우 명시적으로 해결되지 않은 모든 값을 포함하도록 기본 케이스를 정의할 수 있습니다. 기본 케이스는 "},{"type":"codeVoice","code":"default"},{"type":"text","text":" 키워드로 나타내고 항상 마지막에 위치합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 예제는 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문을 사용하여 "},{"type":"codeVoice","code":"someCharacter"},{"type":"text","text":" 의 소문자를 고려합니다:"}]},{"type":"codeListing","syntax":"swift","code":["let someCharacter: Character = \"z\"","switch someCharacter {","case \"a\":","    print(\"The first letter of the alphabet\")","case \"z\":","    print(\"The last letter of the alphabet\")","default:","    print(\"Some other character\")","}","\/\/ Prints \"The last letter of the alphabet\""]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문의 첫번째 케이스는 영어 알파벳의 첫번째 문자인 "},{"type":"codeVoice","code":"a"},{"type":"text","text":" 와 일치하고 두번째 케이스는 마지막 문자인 "},{"type":"codeVoice","code":"z"},{"type":"text","text":" 와 일치합니다. "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 는 모든 알파벳 문자 뿐만 아니라 모든 가능한 문자에 대한 케이스를 가지고 있어야 하므로 이 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문은 "},{"type":"codeVoice","code":"a"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"z"},{"type":"text","text":" 을 제외한 다른 모든 문자는 "},{"type":"codeVoice","code":"default"},{"type":"text","text":" 케이스를 사용합니다. 이렇게 함으로 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문은 완벽하다는 것을 보장합니다."}]},{"anchor":"명시적-Fallthrough-No-Implicit-Fallthrough","level":3,"type":"heading","text":"명시적 Fallthrough (No Implicit Fallthrough)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"C와 Objective-C의 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문과 다르게 Swift의 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문은 기본적으로 각 케이스의 바닥에서 다음 케이스로 바로 실행되지 않습니다. 명시적으로 "},{"type":"codeVoice","code":"break"},{"type":"text","text":" 구문 요청 없이 처음 일치하는 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 케이스가 완료되자마자 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문 전체가 끝납니다. 이러한 점은 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문을 더 안전하고 C의 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문보다 사용하기 쉽게 해주고 실수로 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 케이스가 하나 이상 실행되는 것을 피할 수 있습니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Note"},{"type":"text","text":" "},{"type":"text","text":"Swift에서 "},{"type":"codeVoice","code":"break"},{"type":"text","text":" 는 요구되지 않지만 특정 케이스를 무시하거나 일치하는 케이스의 실행이 완료되기 전에 빠져나와야 할 경우 "},{"type":"codeVoice","code":"break"},{"type":"text","text":" 구문을 사용할 수 있습니다. 자세한 내용은 "},{"type":"reference","isActive":true,"identifier":"doc:ControlFlow#Switch-구문에서-Break-Break-in-a-Switch-Statement"},{"type":"text","text":" 를 참고 바랍니다."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"각 케이스의 본문은 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"반드시"}]},{"type":"text","text":" 적어도 하나의 실행가능한 구문이 포함되어야 합니다. 아래의 코드는 첫번째 케이스가 비어 있으므로 유효하지 않습니다:"}]},{"type":"codeListing","syntax":"swift","code":["let anotherCharacter: Character = \"a\"","switch anotherCharacter {","case \"a\": \/\/ Invalid, the case has an empty body","case \"A\":","    print(\"The letter A\")","default:","    print(\"Not the letter A\")","}","\/\/ This will report a compile-time error."]},{"type":"paragraph","inlineContent":[{"type":"text","text":"C의 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문과 다르게 이 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문은 "},{"type":"codeVoice","code":"\"a\""},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"\"A\""},{"type":"text","text":" 둘다 일치하지 않습니다. "},{"type":"codeVoice","code":"case \"a\":"},{"type":"text","text":" 에 어떠한 실행가능한 구문이 없기 때문에 컴파일 때 에러가 발생합니다. 이 접근 방식은 한 케이스에서 다른 케이스로의 우발적인 실행을 방지하고 의도를 더 명확하게 하고 안전한 코드를 만듭니다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"\"a\""},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"\"A\""},{"type":"text","text":" 모두 일치하는 단일 케이스의 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 를 만드려면 두 값을 콤마로 구분하여 하나로 결합하여 구성합니다."}]},{"type":"codeListing","syntax":"swift","code":["let anotherCharacter: Character = \"a\"","switch anotherCharacter {","case \"a\", \"A\":","    print(\"The letter A\")","default:","    print(\"Not the letter A\")","}","\/\/ Prints \"The letter A\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"읽기 쉽게 하기위해 합성 케이스는 여러줄로 작성할 수도 있습니다. 합성 케이스에 대한 자세한 내용은 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/ControlFlow#%ED%95%A9%EC%84%B1-%EC%BC%80%EC%9D%B4%EC%8A%A4-Compound-Cases"},{"type":"text","text":" 를 참고 바랍니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Note"},{"type":"text","text":" "},{"type":"text","text":"특정 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 케이스에 끝에서 명시적으로 다음 케이스로 떨어뜨리려면 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/ControlFlow#Fallthrough"},{"type":"text","text":" 에서 설명한대로 "},{"type":"codeVoice","code":"fallthrough"},{"type":"text","text":" 키워드를 사용합니다."}]}],"type":"aside","name":"Note"},{"anchor":"간격-일치-Interval-Matching","level":3,"type":"heading","text":"간격 일치 (Interval Matching)"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"switch"},{"type":"text","text":" 케이스 안에 값은 간격을 포함하여 확인할 수 있습니다. 이 예제는 숫자 간격을 사용하여 모든 크기의 숫자에 대한 자연어 갯수를 제공합니다:"}]},{"type":"codeListing","syntax":"swift","code":["let approximateCount = 62","let countedThings = \"moons orbiting Saturn\"","let naturalCount: String","switch approximateCount {","case 0:","    naturalCount = \"no\"","case 1..<5:","    naturalCount = \"a few\"","case 5..<12:","    naturalCount = \"several\"","case 12..<100:","    naturalCount = \"dozens of\"","case 100..<1000:","    naturalCount = \"hundreds of\"","default:","    naturalCount = \"many\"","}","print(\"There are \\(naturalCount) \\(countedThings).\")","\/\/ Prints \"There are dozens of moons orbiting Saturn.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"위의 예제에서 "},{"type":"codeVoice","code":"approximateCount"},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문에서 판단됩니다. 각 "},{"type":"codeVoice","code":"case"},{"type":"text","text":" 는 숫자 값 또는 간격을 비교합니다. "},{"type":"codeVoice","code":"approximateCount"},{"type":"text","text":" 의 값은 12와 100 사이에 속하므로 "},{"type":"codeVoice","code":"naturalCount"},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"\"dozens of\""},{"type":"text","text":" 값이 할당되고 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문을 빠져나옵니다."}]},{"anchor":"튜플-Tuples","level":3,"type":"heading","text":"튜플 (Tuples)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"같은 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문에 여러 값인 튜플을 사용할 수 있습니다. 튜플의 각 요소는 다른 값 또는 값의 간격을 판단할 수 있습니다. 가능한 어떠한 값도 일치하도록 와일드카드 패턴 (wildcard pattern)으로 알려진 언더바 문자 ("},{"type":"codeVoice","code":"_"},{"type":"text","text":")를 사용할 수 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"아래 예제는 타입 "},{"type":"codeVoice","code":"(Int, Int)"},{"type":"text","text":" 의 간단한 튜플로 표현된 (x, y) 포인트를 가지며 그래프에서 분류합니다."}]},{"type":"codeListing","syntax":"swift","code":["let somePoint = (1, 1)","switch somePoint {","case (0, 0):","    print(\"\\(somePoint) is at the origin\")","case (_, 0):","    print(\"\\(somePoint) is on the x-axis\")","case (0, _):","    print(\"\\(somePoint) is on the y-axis\")","case (-2...2, -2...2):","    print(\"\\(somePoint) is inside the box\")","default:","    print(\"\\(somePoint) is outside of the box\")","}","\/\/ Prints \"(1, 1) is inside the box\""]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"coordinateGraphSimple"}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문은 점이 원점 (0, 0) 인지, 빨간색 x축 위에 있는지, 초록색 y축 위에 있는지, 원점이 중심인 파란색 4 x 4 박스 내부에 있는지 외부에 있는지 판단합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"C와 다르게 Swift는 여러 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 케이스가 같은 값 또는 값들인지 고려하는 것이 가능합니다. 사실 점 (0, 0)은 이 예제의 모든 4개의 케이스에 일치합니다. 그러나 여러개가 일치할 수 있다면 첫번째 일치하는 케이스가 항상 사용됩니다. 점 (0, 0)은 첫번째 "},{"type":"codeVoice","code":"case (0, 0)"},{"type":"text","text":" 와 일치하고 다른 모든 케이스는 무시됩니다."}]},{"anchor":"값-바인딩-Value-Bindings","level":3,"type":"heading","text":"값 바인딩 (Value Bindings)"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"switch"},{"type":"text","text":" 케이스는 일치하는 값 또는 값들을 임시적 상수 또는 변수로 이름을 가질 수 있으며 케이스 본문 안에서 사용할 수 있습니다. 값은 케이스의 본문 내부에서 임시적 상수 또는 변수로 바인드 되기 때문에 이러한 동작을 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"값 바인딩 (value binding)"}]},{"type":"text","text":" 이라 합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"아래 예제는 튜플의 타입 "},{"type":"codeVoice","code":"(Int, Int)"},{"type":"text","text":" 로 표현된 점 (x, y)를 가지며 그래프에 분류합니다:"}]},{"type":"codeListing","syntax":"swift","code":["let anotherPoint = (2, 0)","switch anotherPoint {","case (let x, 0):","    print(\"on the x-axis with an x value of \\(x)\")","case (0, let y):","    print(\"on the y-axis with a y value of \\(y)\")","case let (x, y):","    print(\"somewhere else at (\\(x), \\(y))\")","}","\/\/ Prints \"on the x-axis with an x value of 2\""]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"coordinateGraphMedium"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문은 점이 빨간색인 x축에 있는지, 초록색인 y축에 있는지, 또는 다른 곳 (축 위가 아닌)에 있는지 판단합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 3개의 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 케이스는 자리 상수 "},{"type":"codeVoice","code":"x"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"y"},{"type":"text","text":" 를 선언하며 "},{"type":"codeVoice","code":"anotherPoint"},{"type":"text","text":" 에서 임시적으로 하나 또는 2개의 튜플 값을 받습니다. 첫번째 케이스인 "},{"type":"codeVoice","code":"case (let x, 0)"},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"y"},{"type":"text","text":" 점 값이 "},{"type":"codeVoice","code":"0"},{"type":"text","text":" 이고 "},{"type":"codeVoice","code":"x"},{"type":"text","text":" 점 값은 임시적 상수 "},{"type":"codeVoice","code":"x"},{"type":"text","text":" 에 할당한 것과 일치합니다. 비슷하게 두번째 케이스 "},{"type":"codeVoice","code":"case (0, let y)"},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"x"},{"type":"text","text":" 점 값이 "},{"type":"codeVoice","code":"0"},{"type":"text","text":" 이고 "},{"type":"codeVoice","code":"y"},{"type":"text","text":" 점 값은 임시적 상수 "},{"type":"codeVoice","code":"y"},{"type":"text","text":" 에 할당한 것과 일치합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"임시적 상수가 선언된 후에 케이스의 코드 블럭 안에서 사용될 수 있습니다. 여기서는 점을 분리해 출력합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문은 "},{"type":"codeVoice","code":"default"},{"type":"text","text":" 케이스를 가지고 있지 않습니다. 마지막 케이스 "},{"type":"codeVoice","code":"case let (x, y)"},{"type":"text","text":" 는 어떠한 값도 일치할 수 있는 2개의 상수를 가지는 튜플로 선언합니다. "},{"type":"codeVoice","code":"anotherPoint"},{"type":"text","text":" 는 2개 값의 튜플이기 때문에 가능한 남아있는 모든 케이스와 일치하며 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문을 완벽하게 하기위해 "},{"type":"codeVoice","code":"default"},{"type":"text","text":" 케이스가 필요치 않습니다."}]},{"anchor":"Where","level":3,"type":"heading","text":"Where"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"switch"},{"type":"text","text":" 케이스는 추가 조건으로 "},{"type":"codeVoice","code":"where"},{"type":"text","text":" 절을 사용할 수 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"아래 예제는 그래프에 (x, y)를 분류합니다:"}]},{"type":"codeListing","syntax":"swift","code":["let yetAnotherPoint = (1, -1)","switch yetAnotherPoint {","case let (x, y) where x == y:","    print(\"(\\(x), \\(y)) is on the line x == y\")","case let (x, y) where x == -y:","    print(\"(\\(x), \\(y)) is on the line x == -y\")","case let (x, y):","    print(\"(\\(x), \\(y)) is just some arbitrary point\")","}","\/\/ Prints \"(1, -1) is on the line x == -y\""]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"coordinateGraphComplex"}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문은 "},{"type":"codeVoice","code":"x == y"},{"type":"text","text":" 인 초록색 대각선 위에 있는지, "},{"type":"codeVoice","code":"x == -y"},{"type":"text","text":" 인 보라색 대각선 위에 있거나 아니면 그 외에 위치하는지 판단합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"3개의 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 케이스는 "},{"type":"codeVoice","code":"yetAnotherPoint"},{"type":"text","text":" 에서 임시적으로 2개의 튜플 값을 가지는 "},{"type":"codeVoice","code":"x"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"y"},{"type":"text","text":" 상수를 선언합니다. 이 상수는 다이나믹 필터를 생성하기 위해 "},{"type":"codeVoice","code":"where"},{"type":"text","text":" 에 부분적으로 사용됩니다. "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 케이스는 "},{"type":"codeVoice","code":"where"},{"type":"text","text":" 절의 조건이 "},{"type":"codeVoice","code":"true"},{"type":"text","text":" 일 때만 "},{"type":"codeVoice","code":"point"},{"type":"text","text":" 의 현재 값이 일치합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이전 예제와 마찬가지로 마지막 케이스는 가능한 남아있는 값과 모두 일치하므로 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문을 완벽하게 하기 위해 "},{"type":"codeVoice","code":"default"},{"type":"text","text":" 케이스가 필요치 않습니다."}]},{"anchor":"합성-케이스-Compound-Cases","level":3,"type":"heading","text":"합성 케이스 (Compound Cases)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"같은 본문을 공유하는 여러개의 스위치 케이스는 "},{"type":"codeVoice","code":"case"},{"type":"text","text":" 다음에 각 패턴 사이에 콤마로 구분하여 여러개의 패턴으로 결합될 수 있습니다. 여러 패턴 중 어떤 패턴이 일치하면 해당 케이스로 고려됩니다. 패턴이 길면 여러줄로 작성할 수 있습니다. 예를 들어:"}]},{"type":"codeListing","syntax":"swift","code":["let someCharacter: Character = \"e\"","switch someCharacter {","case \"a\", \"e\", \"i\", \"o\", \"u\":","    print(\"\\(someCharacter) is a vowel\")","case \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\",","     \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\":","    print(\"\\(someCharacter) is a consonant\")","default:","    print(\"\\(someCharacter) is not a vowel or a consonant\")","}","\/\/ Prints \"e is a vowel\""]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문의 첫번째 케이스는 영어의 5개의 소문자 모음이 일치합니다. 비슷하게 두번째 케이스는 모든 영어 소문자 자음이 일치합니다. 마지막으로 "},{"type":"codeVoice","code":"default"},{"type":"text","text":" 케이스는 다른 어떠한 문자와 일치합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"혼합 케이스 (Compound cases)는 값 바인딩을 포함할 수도 있습니다. 혼합 케이스의 모든 패턴은 값 바인딩의 같은 집합을 포함해야 하고 각 바인딩은 혼합 케이스에 모든 패턴으로 부터 같은 타입의 값을 얻어야 합니다. 혼합 케이스 부분이 일치하는 것과 상관없이 케이스의 본문에 코드는 바인딩을 위해 값에 항상 접근할 수 있고 값은 항상 같은 타입을 가집니다."}]},{"type":"codeListing","syntax":"swift","code":["let stillAnotherPoint = (9, 0)","switch stillAnotherPoint {","case (let distance, 0), (0, let distance):","    print(\"On an axis, \\(distance) from the origin\")","default:","    print(\"Not on an axis\")","}","\/\/ Prints \"On an axis, 9 from the origin\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"위의 "},{"type":"codeVoice","code":"case"},{"type":"text","text":" 는 2개의 패턴을 가지고 있습니다: "},{"type":"codeVoice","code":"(let distance, 0)"},{"type":"text","text":" 은 x축 위의 점과 일치하고 "},{"type":"codeVoice","code":"(0, let distance)"},{"type":"text","text":" 는 y축 위의 점과 일치합니다. 두 패턴 모두 "},{"type":"codeVoice","code":"distance"},{"type":"text","text":" 바인딩을 포함하고 "},{"type":"codeVoice","code":"distance"},{"type":"text","text":" 는 두 패턴에서 정수입니다. 즉, "},{"type":"codeVoice","code":"case"},{"type":"text","text":" 의 본문 안에 코드는 항상 "},{"type":"codeVoice","code":"distance"},{"type":"text","text":" 로 값에 접근할 수 있다는 의미입니다."}]},{"anchor":"제어-변경-구문-Control-Transfer-Statements","level":2,"type":"heading","text":"제어 변경 구문 (Control Transfer Statements)"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"제어 변경 구문 (Control transfer statements)"}]},{"type":"text","text":" 은 한 코드에서 다른 코드로 제어를 변경하여 코드가 실행되는 순서를 변경합니다. Swift는 5개의 제어 변경 구문이 있습니다:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"continue"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"break"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"fallthrough"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"return"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"throw"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"continue"},{"type":"text","text":", "},{"type":"codeVoice","code":"break"},{"type":"text","text":", "},{"type":"codeVoice","code":"fallthrough"},{"type":"text","text":" 구문은 아래 설명되어 있습니다. "},{"type":"codeVoice","code":"return"},{"type":"text","text":" 구문은 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions"},{"type":"text","text":" 에 설명되어 있고 "},{"type":"codeVoice","code":"throw"},{"type":"text","text":" 구문은 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/ErrorHandling#%EB%8D%98%EC%A7%80%EA%B8%B0-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%97%90%EB%9F%AC-%EC%A0%84%ED%8C%8C-Propagating-Errors-Using-Throwing-Functions"},{"type":"text","text":" 에 설명되어 있습니다."}]},{"anchor":"계속-Continue","level":3,"type":"heading","text":"계속 (Continue)"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"continue"},{"type":"text","text":" 구문은 루프를 통해 다음 반복을 시작하려고 멈추기위해 부릅니다. 이것은 루프를 완전히 벗어나지 않고 “현재 루프 반복은 완료 되었습니다.” 라고 말합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"아래 예제는 비밀의 퍼즐 구문을 생성하기 위해 소문자 문자열에서 모음과 공백을 삭제합니다:"}]},{"type":"codeListing","syntax":"swift","code":["let puzzleInput = \"great minds think alike\"","var puzzleOutput = \"\"","let charactersToRemove: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\", \" \"]","for character in puzzleInput {","    if charactersToRemove.contains(character) {","        continue","    }","    puzzleOutput.append(character)","}","print(puzzleOutput)","\/\/ Prints \"grtmndsthnklk\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"위 코드는 모음 또는 공백이 일치하면 현재 반복의 루프를 종료하고 즉시 다음 반복을 시작하기 위해 "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" 키워드를 호출합니다."}]},{"anchor":"중단-Break","level":3,"type":"heading","text":"중단 (Break)"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"break"},{"type":"text","text":" 구문은 전체 제어흐름 구문을 즉시 종료합니다. "},{"type":"codeVoice","code":"break"},{"type":"text","text":" 구문은 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 내부나 루프 구문에서 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 또는 루프 구문을 다른 경우보다 일찍 종료시킬 때 사용될 수 있습니다."}]},{"anchor":"루프-구문에서-중단-Break-in-a-Loop-Statement","level":4,"type":"heading","text":"루프 구문에서 중단 (Break in a Loop Statement)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"루프 구문 내에서 사용할 때 "},{"type":"codeVoice","code":"break"},{"type":"text","text":" 는 루프의 실행을 즉시 종료하고 제어를 루프의 닫기 중괄호 ("},{"type":"codeVoice","code":"}"},{"type":"text","text":") 다음으로 이전합니다. 루프의 현재 반복으로 부터 코드는 더이상 실행되지 않고 루프의 반복은 더이상 시작되지 않습니다."}]},{"anchor":"Switch-구문에서-중단-Break-in-a-Switch-Statement","level":4,"type":"heading","text":"Switch 구문에서 중단 (Break in a Switch Statement)"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문 내에서 사용할 때 "},{"type":"codeVoice","code":"break"},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문을 즉시 종료하고 제어를 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문의 닫힌 중괄호 ("},{"type":"codeVoice","code":"}"},{"type":"text","text":") 다음으로 이동시킵니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이러한 동작은 일치할 때 사용될 수 있고 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문에서 하나 또는 그 이상의 케이스를 무시할 때 사용됩니다. Swift의 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문은 완벽하고 빈 케이스를 허락하지 않기 때문에 의도를 명시하기 위해 의도적으로 케이스를 일치시키고 무시해야 하는 경우가 있습니다. 무시할 케이스의 전체 본문으로 "},{"type":"codeVoice","code":"break"},{"type":"text","text":" 구문을 작성하여 이를 수행합니다. 해당 케이스가 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문과 일치하면 케이스 내부의 "},{"type":"codeVoice","code":"break"},{"type":"text","text":" 구문이 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문의 실행을 즉시 종료합니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Note"},{"type":"text","text":" "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 케이스에 주석만 포함되어 있으면 컴파일 시 에러가 발생합니다. 주석은 구문이 아니며 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 케이스는 무시되지 않습니다. 항상 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 케이스를 무시하려면 "},{"type":"codeVoice","code":"break"},{"type":"text","text":" 구문을 사용하십시오."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"아래 예제는 "},{"type":"codeVoice","code":"Character"},{"type":"text","text":" 값을 바꾸고 4개의 언어중 하나의 언어로 숫자 기호를 표기하는지 판단합니다. 간결함을 위해 단일 케이스에 여러 값이 포함됩니다."}]},{"type":"codeListing","syntax":"swift","code":["let numberSymbol: Character = \"三\"  \/\/ Chinese symbol for the number 3","var possibleIntegerValue: Int?","switch numberSymbol {","case \"1\", \"١\", \"一\", \"๑\":","    possibleIntegerValue = 1","case \"2\", \"٢\", \"二\", \"๒\":","    possibleIntegerValue = 2","case \"3\", \"٣\", \"三\", \"๓\":","    possibleIntegerValue = 3","case \"4\", \"٤\", \"四\", \"๔\":","    possibleIntegerValue = 4","default:","    break","}","if let integerValue = possibleIntegerValue {","    print(\"The integer value of \\(numberSymbol) is \\(integerValue).\")","} else {","    print(\"An integer value could not be found for \\(numberSymbol).\")","}","\/\/ Prints \"The integer value of 三 is 3.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 예제는 "},{"type":"codeVoice","code":"numberSymbol"},{"type":"text","text":" 이 "},{"type":"codeVoice","code":"1"},{"type":"text","text":" 부터 "},{"type":"codeVoice","code":"4"},{"type":"text","text":" 의 숫자 기호가 라틴어, 아랍어, 중국어, 태국어 인지 판단합니다. 일치하는 것을 찾으면 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문의 케이스 중에 하나는 적절한 정수 값을 "},{"type":"codeVoice","code":"possibleIntegerValue"},{"type":"text","text":" 라 불리는 옵셔널 "},{"type":"codeVoice","code":"Int?"},{"type":"text","text":" 변수에 할당합니다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문 이후에 이 예제는 값이 존재하는지 옵셔널 바인딩을 사용합니다. "},{"type":"codeVoice","code":"possibleIntegerValue"},{"type":"text","text":" 변수는 옵셔널 타입이기 때문에 초기값은 "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" 이므로 "},{"type":"codeVoice","code":"possibleIntegerValue"},{"type":"text","text":" 가 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문의 케이스 중 하나와 일치하여 실제 값이 설정된다면 옵셔널 바인딩은 성공할 것입니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"위 예제에서 가능한 모든 "},{"type":"codeVoice","code":"Character"},{"type":"text","text":" 값을 리스트화 할 수 없기 때문에 "},{"type":"codeVoice","code":"default"},{"type":"text","text":" 케이스로 일치되지 않는 문자를 처리합니다. "},{"type":"codeVoice","code":"default"},{"type":"text","text":" 케이스는 어떠한 동작도 수행할 필요가 없으므로 "},{"type":"codeVoice","code":"break"},{"type":"text","text":" 구문만 적습니다. "},{"type":"codeVoice","code":"default"},{"type":"text","text":" 케이스에 일치되자마자 "},{"type":"codeVoice","code":"break"},{"type":"text","text":" 구문은 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문의 실행을 종료하고 이어서 "},{"type":"codeVoice","code":"if let"},{"type":"text","text":" 구문을 실행합니다."}]},{"anchor":"Fallthrough","level":3,"type":"heading","text":"Fallthrough"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift에서 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문은 각 케이스의 맨 아래에서 다음 케이스로 넘어가지 않습니다. 첫번째 케이스가 일치하자마자 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문의 실행은 완료됩니다. 반대로 C는 다음 케이스로 넘어가는 것을 막기 위해 모든 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 케이스 마지막에 명시적으로 "},{"type":"codeVoice","code":"break"},{"type":"text","text":" 구문을 명시적으로 넣어야 합니다. 기본적으로 다음 케이스로 넘어가지 않는다는 것은 Swift의 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문이 C의 대응문 보다 훨씬 간결하고 예측 가능하다는 것을 의미하므로 실수로 여러 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 케이스를 실행하지 않습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"C 처럼 다음 케이스로 넘어가려면 "},{"type":"codeVoice","code":"fallthrough"},{"type":"text","text":" 키워드로 케이스 별로 동작을 선택할 수 있습니다. 아래 예에서 "},{"type":"codeVoice","code":"fallthrough"},{"type":"text","text":" 를 사용하여 숫자의 설명을 생성합니다."}]},{"type":"codeListing","syntax":"swift","code":["let integerToDescribe = 5","var description = \"The number \\(integerToDescribe) is\"","switch integerToDescribe {","case 2, 3, 5, 7, 11, 13, 17, 19:","    description += \" a prime number, and also\"","    fallthrough","default:","    description += \" an integer.\"","}","print(description)","\/\/ Prints \"The number 5 is a prime number, and also an integer.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 예제는 "},{"type":"codeVoice","code":"description"},{"type":"text","text":" 이라 불리는 새로운 "},{"type":"codeVoice","code":"String"},{"type":"text","text":" 변수를 선언하고 초기값을 할당합니다. 이 함수는 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문을 사용하여 "},{"type":"codeVoice","code":"integerToDescribe"},{"type":"text","text":" 의 값을 고려합니다. "},{"type":"codeVoice","code":"integerToDescribe"},{"type":"text","text":" 의 값이 리스트에서의 소수 중 하나이면 소수라는 것을 나타내는 텍스트를 "},{"type":"codeVoice","code":"description"},{"type":"text","text":" 뒤에 추가합니다. 그러면 "},{"type":"codeVoice","code":"fallthrough"},{"type":"text","text":" 키워드를 사용하여 "},{"type":"codeVoice","code":"default"},{"type":"text","text":" 케이스 또한 동작하게 됩니다. "},{"type":"codeVoice","code":"default"},{"type":"text","text":" 케이스는 추가 설명을 덧붙이고 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문은 완료됩니다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"integerToDescribe"},{"type":"text","text":" 의 값이 리스트에 없는 소수이면 첫번째 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 케이스와 전혀 일치하지 않습니다. 특정 케이스가 없기 때문에 "},{"type":"codeVoice","code":"integerToDescribe"},{"type":"text","text":" 는 "},{"type":"codeVoice","code":"default"},{"type":"text","text":" 케이스와 일치됩니다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문 실행이 완료된 후에 숫자의 설명은 "},{"type":"codeVoice","code":"print(_:separator:terminator:)"},{"type":"text","text":" 함수를 사용하여 출력됩니다. 이 예제에서 숫자 "},{"type":"codeVoice","code":"5"},{"type":"text","text":" 는 소수로써 유효합니다."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Note"},{"type":"text","text":" "},{"type":"codeVoice","code":"fallthrough"},{"type":"text","text":" 키워드는 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 케이스 실행을 위한 케이스 조건을 확인하지 않습니다. "},{"type":"codeVoice","code":"fallthrough"},{"type":"text","text":" 키워드는 간단하게 C의 표준 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문 동작처럼 다음 케이스 또는 "},{"type":"codeVoice","code":"default"},{"type":"text","text":" 케이스로 코드 실행을 직접적으로 이동시킵니다."}]}],"type":"aside","name":"Note"},{"anchor":"라벨이-있는-구문-Labeled-Statements","level":3,"type":"heading","text":"라벨이 있는 구문 (Labeled Statements)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift에서 복잡한 제어흐름 구조를 생성하기 위해 루프와 조건 구문내에 다른 루프와 조건 구문을 중첩할 수 있습니다. 그러나 루프와 조건 구문은 모두 실행을 조기 종료하기 위해 "},{"type":"codeVoice","code":"break"},{"type":"text","text":" 구문을 사용할 수 있습니다. 따라서 "},{"type":"codeVoice","code":"break"},{"type":"text","text":" 구문으로 종료될 루프나 조건 구문에 라벨을 붙이는 것이 유용할 때가 있습니다. 마찬가지로 여러개의 중첩된 루프를 가지고 있다면 "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" 구문에 영향을 받는 루프에 라벨을 붙이는 것이 유용할 수 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이러한 목적을 달성하기 위해 루프 구문 또는 조건 구문에 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"구문 라벨 (statement label)"}]},{"type":"text","text":" 을 표기할 수 있습니다. 조건 구문에서 라벨이 있는 구문에 실행을 종료하기 위해 "},{"type":"codeVoice","code":"break"},{"type":"text","text":" 구문과 구문 라벨을 사용할 수 있습니다. 루프 구문에서 라벨이 있는 구문에 실행을 종료하거나 이어서 진행하기 위해 "},{"type":"codeVoice","code":"break"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" 구문과 구문 라벨을 사용할 수 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"라벨이 있는 구문 (labeled statement)은 구문의 소개자 키워드와 같은 줄에 위치하고 바로 다음에 콜론이 옵니다. 여기 예제는 "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프에 대한 구문의 예입니다. 모든 루프와 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문에 대해 동일합니다:"}]},{"type":"codeListing","syntax":"swift","code":["<#label name#>: while <#condition#> {","   <#statements#>","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"다음 예제는 이 챕터의 이전에 봤던 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Snakes and Ladders"}]},{"type":"text","text":" 게임에 적절한 버전을 위해 라벨이 있는 "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프와 "},{"type":"codeVoice","code":"break"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" 구문을 사용합니다. 이번에는 게임에 추가 규칙이 있습니다:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"이기려면 정사각형 25에 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"정확히"}]},{"type":"text","text":" 위치해야 합니다."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"주사위를 굴려 정사각형 25를 넘어간다면 정확히 정사각형 25에 위치할 때까지 주사위를 굴려야 합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"게임 보드는 이전과 동일합니다."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"snakesAndLadders"}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"finalSquare"},{"type":"text","text":", "},{"type":"codeVoice","code":"board"},{"type":"text","text":", "},{"type":"codeVoice","code":"square"},{"type":"text","text":", "},{"type":"codeVoice","code":"diceRoll"},{"type":"text","text":" 은 이전과 동일하게 초기화 됩니다:"}]},{"type":"codeListing","syntax":"swift","code":["let finalSquare = 25","var board = [Int](repeating: 0, count: finalSquare + 1)","board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02","board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08","var square = 0","var diceRoll = 0"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"이 게임 버전에서는 로직을 위해 "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프와 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문을 사용합니다. "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프는 Snakes and Ladders 게임의 메인 게임 루프를 나타내는 "},{"type":"codeVoice","code":"gameLoop"},{"type":"text","text":" 라는 구문 라벨을 가지고 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프의 조건은 정사각형 25에 정확하게 착지를 위한 조건을 반영한 "},{"type":"codeVoice","code":"while square != finalSquare"},{"type":"text","text":" 입니다."}]},{"type":"codeListing","syntax":"swift","code":["gameLoop: while square != finalSquare {","    diceRoll += 1","    if diceRoll == 7 { diceRoll = 1 }","    switch square + diceRoll {","    case finalSquare:","        \/\/ diceRoll will move us to the final square, so the game is over","        break gameLoop","    case let newSquare where newSquare > finalSquare:","        \/\/ diceRoll will move us beyond the final square, so roll again","        continue gameLoop","    default:","        \/\/ this is a valid move, so find out its effect","        square += diceRoll","        square += board[square]","    }","}","print(\"Game over!\")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"각 루프가 시작될 때 주사위는 굴려집니다. 즉시 플레이어를 이동하는 것보다 루프는 이동의 결과를 고려하고 이동이 가능한지 판단하기 위해 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문을 사용합니다:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"주사위 굴림이 플레이어를 마지막 정사각형으로 이동시킨다면 게임은 종료됩니다. "},{"type":"codeVoice","code":"break gameLoop"},{"type":"text","text":" 구문은 게임 종료를 위해 "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프의 바깥으로 제어를 이동합니다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"주사위 굴림이 플레이어를 마지막 정사각형을 넘어 이동시킨다면 이 이동은 유효하지 않고 플레이어는 주사위를 다시 굴려야 합니다. "},{"type":"codeVoice","code":"continue gameLoop"},{"type":"text","text":" 구문은 현재 "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 루프 반복을 종료하고 루프의 다음 반복을 시작합니다."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"다른 모든 케이스에 해당하는 주사위 굴림은 유효합니다. 플레이어는 "},{"type":"codeVoice","code":"diceRoll"},{"type":"text","text":" 만큼 이동하고 게임 로직은 뱀과 사다리에 대해 확인합니다. 그러면 루프는 종료되고 다음 턴이 요구되는지 결정하기 위해 "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 조건으로 되돌아 갑니다."}]}]}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Note"},{"type":"text","text":" "},{"type":"text","text":"위에서 "},{"type":"codeVoice","code":"break"},{"type":"text","text":" 구문을 "},{"type":"codeVoice","code":"gameLoop"},{"type":"text","text":" 라벨 없이 사용하면 "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 구문을 빠져나오는 것이 아니라 "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" 구문을 빠져나옵니다. "},{"type":"codeVoice","code":"gameLoop"},{"type":"text","text":" 라벨을 사용하는 것은 제어 구문을 종료하기 위해 명확하도록 만들어 줍니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"루프의 다음 반복으로 이동하기위해 "},{"type":"codeVoice","code":"continue gameLoop"},{"type":"text","text":" 호출할 때 "},{"type":"codeVoice","code":"gameLoop"},{"type":"text","text":" 라벨을 사용하는 것은 필요하지 않습니다. 게임에서 오직 하나의 루프만 존재하므로 루프는 "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" 구문의 영향을 받습니다. 그러나 "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" 구문과 함께 "},{"type":"codeVoice","code":"gameLoop"},{"type":"text","text":" 라벨을 사용해도 아무런 문제가 없습니다. 이렇게 하면 "},{"type":"codeVoice","code":"break"},{"type":"text","text":" 구문과 일치하며 게임의 로직을 더 명확하게 읽고 이해하는데 도움을 줍니다."}]}],"type":"aside","name":"Note"},{"anchor":"이른-종료-Early-Exit","level":2,"type":"heading","text":"이른 종료 (Early Exit)"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"if"},{"type":"text","text":" 구문과 같이 "},{"type":"codeVoice","code":"guard"},{"type":"text","text":" 구문은 표현식의 부울 값에 따라 구문을 실행합니다. "},{"type":"codeVoice","code":"guard"},{"type":"text","text":" 구문은 "},{"type":"codeVoice","code":"guard"},{"type":"text","text":" 구문의 다음을 실행하기 위해 반드시 조건이 참인 것을 요구하기 위해 사용합니다. "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 구문과 반대로 "},{"type":"codeVoice","code":"guard"},{"type":"text","text":" 구문은 항상 "},{"type":"codeVoice","code":"else"},{"type":"text","text":" 절을 가지고 있습니다. "},{"type":"codeVoice","code":"else"},{"type":"text","text":" 절 안의 코드는 조건이 참이 아닐 경우에 실행됩니다."}]},{"type":"codeListing","syntax":"swift","code":["func greet(person: [String: String]) {","    guard let name = person[\"name\"] else {","        return","    }","","    print(\"Hello \\(name)!\")","","    guard let location = person[\"location\"] else {","        print(\"I hope the weather is nice near you.\")","        return","    }","","    print(\"I hope the weather is nice in \\(location).\")","}","","greet(person: [\"name\": \"John\"])","\/\/ Prints \"Hello John!\"","\/\/ Prints \"I hope the weather is nice near you.\"","greet(person: [\"name\": \"Jane\", \"location\": \"Cupertino\"])","\/\/ Prints \"Hello Jane!\"","\/\/ Prints \"I hope the weather is nice in Cupertino.\""]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"guard"},{"type":"text","text":" 구문의 조건이 충족되면 코드 실행은 "},{"type":"codeVoice","code":"guard"},{"type":"text","text":" 구문의 닫는 중괄호 다음으로 이어집니다. 조건의 일부로 옵셔널 바인딩을 사용하여 값이 할당된 모든 변수 또는 상수는 "},{"type":"codeVoice","code":"guard"},{"type":"text","text":" 문이 존재하는 나머지 코드 블럭에서 사용할 수 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"조건이 충족되지 않으면 "},{"type":"codeVoice","code":"else"},{"type":"text","text":" 안의 코드가 실행됩니다. 이 블럭은 반드시 "},{"type":"codeVoice","code":"guard"},{"type":"text","text":" 구문이 존재하는 코드 블럭을 종료하기 위해 제어를 이동해야 합니다. "},{"type":"codeVoice","code":"return"},{"type":"text","text":", "},{"type":"codeVoice","code":"break"},{"type":"text","text":", "},{"type":"codeVoice","code":"continue"},{"type":"text","text":", "},{"type":"codeVoice","code":"throw"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"fatalError(_:file:line:)"},{"type":"text","text":" 과 같은 되돌아 가지 않는 함수 또는 메서드 같은 구문으로 제어를 이동할 수 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"필요조건을 위한 "},{"type":"codeVoice","code":"guard"},{"type":"text","text":" 구문 사용은 같은걸 확인하는 "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 구문과 비교하여 코드를 더 읽기 좋게 해줍니다. 이를 통해 일반적으로 실행되는 코드를 "},{"type":"codeVoice","code":"else"},{"type":"text","text":" 블럭으로 래핑하지 않고 작성할 수 있으며 요구에 충족하지 않는 부분을 요구사항 근처에서 처리할 수 있도록 해줍니다."}]},{"anchor":"연기된-동작-Deferred-Actions","level":2,"type":"heading","text":"연기된 동작 (Deferred Actions)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"코드의 일부분이 실행되거나 실행 횟수를 제어할 수 있는 "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 와 "},{"type":"codeVoice","code":"while"},{"type":"text","text":" 과 같은 제어 흐름 구조와 다르게 "},{"type":"codeVoice","code":"defer"},{"type":"text","text":" 는 코드 일부분이 실행되는 시기를 제어합니다. 현재 범위의 마지막에 실행되는 코드블럭을 작성하기 위해 "},{"type":"codeVoice","code":"defer"},{"type":"text","text":" 블럭을 사용합니다. 예를 들어:"}]},{"type":"codeListing","syntax":"swift","code":["var score = 1","if score < 10 {","    defer {","        print(score)","    }","    score += 5","}","\/\/ Prints \"6\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"위의 예제에서 "},{"type":"codeVoice","code":"defer"},{"type":"text","text":" 블럭 안의 코드는 "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 구문의 본문이 종료되기 전에 실행됩니다. 먼저 "},{"type":"codeVoice","code":"score"},{"type":"text","text":" 를 5 증가시키는 "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 구문의 코드가 수행됩니다. 그런다음 "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 구문의 범위가 종료되기 전에 "},{"type":"codeVoice","code":"score"},{"type":"text","text":" 를 보여주는 연기된 코드가 수행됩니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"프로그램이 어떻게 종료하는지에 관계없이 "},{"type":"codeVoice","code":"defer"},{"type":"text","text":" 안의 코드는 항상 수행됩니다. 여기에는 함수의 이른 종료, "},{"type":"codeVoice","code":"for"},{"type":"text","text":" 루프의 중단 또는 에러를 던지는 동작도 포함됩니다. 수동으로 메모리 할당과 해제, 저수준 파일 열기와 닫기, 데이터베이스에서 트랜젝션 시작과 종료와 같은 동작에서 "},{"type":"codeVoice","code":"defer"},{"type":"text","text":" 는 이러한 동작을 나란히 작성할 수 있기때문에 쌍으로 수행되는 동작을 보장할 때 유용합니다. 예를 들어 다음의 코드는 점수에 100을 더하고 뺌으로써 임시로 보너스를 주는 코드입니다:"}]},{"type":"codeListing","syntax":"swift","code":["var score = 3","if score < 100 {","    score += 100","    defer {","        score -= 100","    }","    \/\/ Other code that uses the score with its bonus goes here.","    print(score)","}","\/\/ Prints \"103\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"같은 범위에 하나 이상의 "},{"type":"codeVoice","code":"defer"},{"type":"text","text":" 블럭을 작성하면 첫번째 "},{"type":"codeVoice","code":"defer"},{"type":"text","text":" 블럭은 마지막에 수행됩니다."}]},{"type":"codeListing","syntax":"swift","code":["if score < 10 {","    defer {","        print(score)","    }","    defer {","        print(\"The score is:\")","    }","    score += 5","}","\/\/ Prints \"The score is:\"","\/\/ Prints \"6\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"예를 들어 런타임 에러나 충돌로 인해 프로그램 수행이 멈추면 연기된 코드는 수행되지 않습니다. 그러나 연기된 코드는 에러가 발생한 후에 수행됩니다; 에러 처리에 대한 "},{"type":"codeVoice","code":"defer"},{"type":"text","text":" 사용의 정보는 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/ErrorHandling#%EC%A0%95%EB%A6%AC-%EC%9E%91%EC%97%85-%EC%A7%80%EC%A0%95-Specifying-Cleanup-Actions"},{"type":"text","text":" 을 참고 바랍니다."}]},{"anchor":"사용-가능한-API-확인-Checking-API-Availability","level":2,"type":"heading","text":"사용 가능한 API 확인 (Checking API Availability)"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift는 주어진 타겟에서 사용 불가능한 API를 실수로 사용하는 것을 막기위해 사용 가능한 API 확인 (checking API availability)을 제공합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"컴파일러는 사용된 API가 프로젝트에 특정 타겟에서 사용 가능한지 확인하기 위해 SDK 안에 사용 가능한 정보를 사용합니다. Swift는 사용 불가능한 API에 대해 컴파일 시 에러를 발생합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"사용하려는 API를 런타임에 사용할 수 있는지 여부에 따라 "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 또는 "},{"type":"codeVoice","code":"guard"},{"type":"text","text":" 구문에서 "},{"type":"emphasis","inlineContent":[{"type":"text","text":"가용성 조건 (availability condition)"}]},{"type":"text","text":" 을 사용하여 코드 블럭을 조건부로 실행합니다. 컴파일러는 해당 코드 블럭의 API를 사용할 수 있는지 확인할 때 가용성 조건의 정보를 사용합니다."}]},{"type":"codeListing","syntax":"swift","code":["if #available(iOS 10, macOS 10.12, *) {","    \/\/ Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS","} else {","    \/\/ Fall back to earlier iOS and macOS APIs","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"iOS에서 위의 특정 가용성 조건의 "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 구문의 본문은 iOS 10 이상 버전에서만 실행되고 macOS에서는 macOS 10.12 이상 버전에서만 실행됩니다. 마지막 인수 "},{"type":"codeVoice","code":"*"},{"type":"text","text":" 는 필수이며 다른 플랫폼에서 "},{"type":"codeVoice","code":"if"},{"type":"text","text":" 의 본문이 최소 타겟 버전에서 실행되도록 지정합니다."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"일반적인 형식에서 가용성 조건은 플랫폼 이름 및 버전 리스트을 사용합니다. "},{"type":"codeVoice","code":"iOS"},{"type":"text","text":", "},{"type":"codeVoice","code":"macOS"},{"type":"text","text":", "},{"type":"codeVoice","code":"watchOS"},{"type":"text","text":", "},{"type":"codeVoice","code":"tvOS"},{"type":"text","text":" 와 같은 플랫폼 이름을 사용하고 자세한 내용은 "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Attributes#%EC%84%A0%EC%96%B8-%EC%86%8D%EC%84%B1-Declaration-Attributes"},{"type":"text","text":" 을 참고 바랍니다. iOS 8 또는 macOS 10.10과 같은 메이저 버전 번호를 지정하는 것 외에 iOS 11.2.6과 macOS 10.13.3과 같은 마이너 버전 번호로 지정할 수 있습니다."}]},{"type":"codeListing","syntax":"swift","code":["if #available(<#platform name#> <#version#>, <#...#>, *) {","    <#statements to execute if the APIs are available#>","} else {","    <#fallback statements to execute if the APIs are unavailable#>","}"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"guard"},{"type":"text","text":" 구문과 함께 가용성 조건을 사용할 때 이것은 코드 블럭에서 나머지 코드에 대한 가용성 정보를 구체화 합니다."}]},{"type":"codeListing","syntax":"swift","code":["@available(macOS 10.12, *)","struct ColorPreference {","    var bestColor = \"blue\"","}","","func chooseBestColor() -> String {","    guard #available(macOS 10.12, *) else {","        return \"gray\"","    }","    let colors = ColorPreference()","    return colors.bestColor","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"위의 예제에서 "},{"type":"codeVoice","code":"ColorPreference"},{"type":"text","text":" 구조체는 macOS 10.12 이상을 요구합니다. "},{"type":"codeVoice","code":"chooseBestColor()"},{"type":"text","text":" 함수는 가용성 가드로 시작합니다. 플랫폼 버전이 "},{"type":"codeVoice","code":"ColorPreference"},{"type":"text","text":" 를 사용하기에 너무 예전 버전이면 항상 사용 가능한 동작으로 대체됩니다. "},{"type":"codeVoice","code":"guard"},{"type":"text","text":" 구문 이후는 macOS 10.12 이상 버전을 요구하는 API 를 사용할 수 있습니다."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"#available"},{"type":"text","text":" 이외에도 Swift 는 비가용성 조건을 사용하여 반대로 확인할 수도 있습니다. 예를 들어, 아래의 내용은 동일한 내용을 확인합니다:"}]},{"type":"codeListing","syntax":"swift","code":["if #available(iOS 10, *) {","} else {","    \/\/ Fallback code","}","","if #unavailable(iOS 10) {","    \/\/ Fallback code","}"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"#unavailable"},{"type":"text","text":" 를 사용하는 형식은 대체 코드만을 포함할 때 더 읽기 쉬운 코드로 만들어 줍니다."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"identifier":{"url":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/ControlFlow","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"분기, 루프, 이른 종료로 코드를 구성합니다."}],"kind":"article","metadata":{"title":"제어 흐름 (Control Flow)"},"hierarchy":{"paths":[["doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean"]]},"references":{"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean":{"role":"collection","title":"The Swift Programming Language (한국어)","abstract":[],"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language-korean"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/ControlFlow#Fallthrough":{"abstract":[],"title":"Fallthrough","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/ControlFlow#Fallthrough","url":"\/documentation\/the-swift-programming-language-korean\/controlflow#Fallthrough"},"coordinateGraphSimple":{"alt":"Coordinate Graph Simple","type":"image","identifier":"coordinateGraphSimple","variants":[{"url":"\/images\/coordinateGraphSimple@2x.png","traits":["2x","light"]},{"url":"\/images\/coordinateGraphSimple~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/CollectionTypes":{"role":"article","title":"콜렉션 타입 (Collection Types)","abstract":[{"type":"text","text":"배열, 집합, 그리고 딕셔너리를 사용하여 데이터를 구성합니다."}],"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/CollectionTypes","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language-korean\/collectiontypes"},"coordinateGraphMedium":{"alt":"Coordinate Graph Medium","type":"image","identifier":"coordinateGraphMedium","variants":[{"url":"\/images\/coordinateGraphMedium@2x.png","traits":["2x","light"]},{"url":"\/images\/coordinateGraphMedium~dark@2x.png","traits":["2x","dark"]}]},"snakesAndLadders":{"alt":"Snakes and Ladders","type":"image","identifier":"snakesAndLadders","variants":[{"url":"\/images\/snakesAndLadders@2x.png","traits":["2x","light"]},{"url":"\/images\/snakesAndLadders~dark@2x.png","traits":["2x","dark"]}]},"doc:ControlFlow#Switch-구문에서-Break-Break-in-a-Switch-Statement":{"title":"doc:ControlFlow#Switch-구문에서-Break-Break-in-a-Switch-Statement","titleInlineContent":[{"type":"text","text":"doc:ControlFlow#Switch-구문에서-Break-Break-in-a-Switch-Statement"}],"type":"link","identifier":"doc:ControlFlow#Switch-구문에서-Break-Break-in-a-Switch-Statement","url":"doc:ControlFlow#Switch-구문에서-Break-Break-in-a-Switch-Statement"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Functions":{"role":"article","title":"함수 (Functions)","abstract":[{"type":"text","text":"함수, 인수 라벨을 정의하고 호출하고 반환값을 사용합니다."}],"identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Functions","kind":"article","type":"topic","url":"\/documentation\/the-swift-programming-language-korean\/functions"},"coordinateGraphComplex":{"alt":"Coordinate Graph Complex","type":"image","identifier":"coordinateGraphComplex","variants":[{"url":"\/images\/coordinateGraphComplex@2x.png","traits":["2x","light"]},{"url":"\/images\/coordinateGraphComplex~dark@2x.png","traits":["2x","dark"]}]},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/ErrorHandling#%EB%8D%98%EC%A7%80%EA%B8%B0-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%97%90%EB%9F%AC-%EC%A0%84%ED%8C%8C-Propagating-Errors-Using-Throwing-Functions":{"abstract":[],"title":"던지기 함수를 이용한 에러 전파 (Propagating Errors Using Throwing Functions)","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/ErrorHandling#%EB%8D%98%EC%A7%80%EA%B8%B0-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%97%90%EB%9F%AC-%EC%A0%84%ED%8C%8C-Propagating-Errors-Using-Throwing-Functions","url":"\/documentation\/the-swift-programming-language-korean\/errorhandling#%25EB%258D%2598%25EC%25A7%2580%25EA%25B8%25B0-%25ED%2595%25A8%25EC%2588%2598%25EB%25A5%25BC-%25EC%259D%25B4%25EC%259A%25A9%25ED%2595%259C-%25EC%2597%2590%25EB%259F%25AC-%25EC%25A0%2584%25ED%258C%258C-Propagating-Errors-Using-Throwing-Functions"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/BasicOperators#%EB%B2%94%EC%9C%84-%EC%97%B0%EC%82%B0%EC%9E%90-Range-Operators":{"abstract":[],"title":"범위 연산자 (Range Operators)","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/BasicOperators#%EB%B2%94%EC%9C%84-%EC%97%B0%EC%82%B0%EC%9E%90-Range-Operators","url":"\/documentation\/the-swift-programming-language-korean\/basicoperators#%25EB%25B2%2594%25EC%259C%2584-%25EC%2597%25B0%25EC%2582%25B0%25EC%259E%2590-Range-Operators"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/ControlFlow#%ED%95%A9%EC%84%B1-%EC%BC%80%EC%9D%B4%EC%8A%A4-Compound-Cases":{"abstract":[],"title":"합성 케이스 (Compound Cases)","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/ControlFlow#%ED%95%A9%EC%84%B1-%EC%BC%80%EC%9D%B4%EC%8A%A4-Compound-Cases","url":"\/documentation\/the-swift-programming-language-korean\/controlflow#%25ED%2595%25A9%25EC%2584%25B1-%25EC%25BC%2580%25EC%259D%25B4%25EC%258A%25A4-Compound-Cases"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/ErrorHandling#%EC%A0%95%EB%A6%AC-%EC%9E%91%EC%97%85-%EC%A7%80%EC%A0%95-Specifying-Cleanup-Actions":{"abstract":[],"title":"정리 작업 지정 (Specifying Cleanup Actions)","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/ErrorHandling#%EC%A0%95%EB%A6%AC-%EC%9E%91%EC%97%85-%EC%A7%80%EC%A0%95-Specifying-Cleanup-Actions","url":"\/documentation\/the-swift-programming-language-korean\/errorhandling#%25EC%25A0%2595%25EB%25A6%25AC-%25EC%259E%2591%25EC%2597%2585-%25EC%25A7%2580%25EC%25A0%2595-Specifying-Cleanup-Actions"},"doc://org.swift.tsplk/documentation/The-Swift-Programming-Language-Korean/Attributes#%EC%84%A0%EC%96%B8-%EC%86%8D%EC%84%B1-Declaration-Attributes":{"abstract":[],"title":"선언 속성 (Declaration Attributes)","kind":"section","type":"topic","identifier":"doc:\/\/org.swift.tsplk\/documentation\/The-Swift-Programming-Language-Korean\/Attributes#%EC%84%A0%EC%96%B8-%EC%86%8D%EC%84%B1-Declaration-Attributes","url":"\/documentation\/the-swift-programming-language-korean\/attributes#%25EC%2584%25A0%25EC%2596%25B8-%25EC%2586%258D%25EC%2584%25B1-Declaration-Attributes"},"https://developer.apple.com/documentation/swift/sequence":{"title":"시퀀스 (Sequence)","titleInlineContent":[{"type":"text","text":"시퀀스 (Sequence)"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/sequence","url":"https:\/\/developer.apple.com\/documentation\/swift\/sequence"}}}